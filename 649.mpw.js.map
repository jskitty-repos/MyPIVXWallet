{"version":3,"file":"./649.mpw.js","mappings":"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","sources":["webpack://MPW/webpack/runtime/chunk loaded","webpack://MPW/webpack/runtime/create fake namespace object","webpack://MPW/webpack/runtime/startup chunk dependencies","webpack://MPW/./scripts/utils.js","webpack://MPW/./scripts/chain_params.js","webpack://MPW/./scripts/misc.js","webpack://MPW/./scripts/i18n.js","webpack://MPW/./scripts/event_bus.js","webpack://MPW/./scripts/prices.js","webpack://MPW/./scripts/settings.js","webpack://MPW/./scripts/mempool.js","webpack://MPW/./scripts/global.js","webpack://MPW/./scripts/network.js","webpack://MPW/./scripts/aes-gcm.js","webpack://MPW/./scripts/wallet.js","webpack://MPW/./scripts/vanitygen_worker.js","webpack://MPW/webpack/bootstrap","webpack://MPW/webpack/runtime/compat get default export","webpack://MPW/webpack/runtime/define property getters","webpack://MPW/webpack/runtime/ensure chunk","webpack://MPW/webpack/runtime/get javascript chunk filename","webpack://MPW/webpack/runtime/get mini-css chunk filename","webpack://MPW/webpack/runtime/global","webpack://MPW/webpack/runtime/hasOwnProperty shorthand","webpack://MPW/webpack/runtime/make namespace object","webpack://MPW/webpack/runtime/node module decorator","webpack://MPW/webpack/runtime/publicPath","webpack://MPW/webpack/runtime/importScripts chunk loading","webpack://MPW/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(418).then(next);\n};","import { Buffer } from 'buffer';\nimport { sha256 } from '@noble/hashes/sha256';\n\nexport function hexToBytes(str) {\n    return Buffer.from(str, 'hex');\n}\n\nexport function bytesToHex(bytes) {\n    return Buffer.from(bytes).toString('hex');\n}\n\n/**\n   @returns {Uint8Array} double sha256 or the buffer\n */\nexport function dSHA256(buff) {\n    return sha256(sha256(new Uint8Array(buff)));\n}\n","// In most BTC-derived coins, the below parameters can be found in the 'src/chainparams.cpp' Mainnet configuration.\n// These below params share the same names as the CPP params, so finding and editing these is easy-peasy!\n// <[network_byte] [32_byte_payload] [0x01] [4_byte_checksum]>\nexport const PRIVKEY_BYTE_LENGTH = 38;\n\nexport const COIN_DECIMALS = 8;\nexport const COIN = 10 ** 8;\n\n/** The maximum gap (absence of transactions within a range of derived addresses) before an account search ends */\nexport const MAX_ACCOUNT_GAP = 20;\n\n/* Internal tweaking parameters */\n// A new encryption password must be 'at least' this long.\nexport const MIN_PASS_LENGTH = 6;\n\n/* chainparams */\nexport const cChainParams = {\n    current: null,\n    main: {\n        collateralInSats: 10000 * COIN,\n        isTestnet: false,\n        TICKER: 'PIV',\n        PUBKEY_PREFIX: ['D'],\n        STAKING_PREFIX: 'S',\n        PUBKEY_ADDRESS: 30,\n        SECRET_KEY: 212,\n        BIP44_TYPE: 119,\n        BIP44_TYPE_LEDGER: 77,\n        PROTOCOL_VERSION: 70926,\n        MASTERNODE_PORT: 51472,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'rockdev', url: 'https://explorer.rockdev.org' },\n            { name: 'zkBitcoin', url: 'https://zkbitcoin.com' },\n        ],\n        Nodes: [{ name: 'duddino', url: 'https://rpc.duddino.com/mainnet' }],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n    },\n    testnet: {\n        collateralInSats: 10000 * COIN,\n        isTestnet: true,\n        TICKER: 'tPIV',\n        PUBKEY_PREFIX: ['x', 'y'],\n        STAKING_PREFIX: 'W',\n        PUBKEY_ADDRESS: 139,\n        SECRET_KEY: 239,\n        BIP44_TYPE: 1,\n        BIP44_TYPE_LEDGER: 1,\n        PROTOCOL_VERSION: 70926,\n        MASTERNODE_PORT: 51474,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'rockdev', url: 'https://testnet.rockdev.org' },\n        ],\n        Nodes: [{ name: 'duddino', url: 'https://rpc.duddino.com/testnet' }],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n    },\n};\n// Set default chain\ncChainParams.current = cChainParams.main;\n","import { translateAlerts } from './i18n.js';\nimport { doms } from './global.js';\nimport qrcode from 'qrcode-generator';\nimport bs58 from 'bs58';\nimport { cChainParams } from './chain_params';\nimport { hexToBytes, bytesToHex } from './utils.js';\n\n/* MPW constants */\nexport const pubKeyHashNetworkLen = 21;\nexport const pubChksum = 4;\nexport const pubPrebaseLen = pubKeyHashNetworkLen + pubChksum;\n\n// Base58 Encoding Map\nexport const MAP_B58 =\n    '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport const LEN_B58 = MAP_B58.length;\n\n/* --- UTILS --- */\n// Cryptographic Random-Gen\nexport function getSafeRand(nSize = 32) {\n    return crypto.getRandomValues(new Uint8Array(nSize));\n}\n\n// Writes a sequence of Array-like bytes into a location within a Uint8Array\nexport function writeToUint8(arr, bytes, pos) {\n    const arrLen = arr.length;\n    // Sanity: ensure an overflow cannot occur, if one is detected, somewhere in MPW's state could be corrupted.\n    if (arrLen - pos - bytes.length < 0) {\n        const strERR =\n            'CRITICAL: Overflow detected (' +\n            (arrLen - pos - bytes.length) +\n            '), possible state corruption, backup and refresh advised.';\n        createAlert('warning', strERR, 5000);\n        throw Error(strERR);\n    }\n    let i = 0;\n    while (pos < arrLen) arr[pos++] = bytes[i++];\n}\n\n/* --- NOTIFICATIONS --- */\n// Alert - Do NOT display arbitrary / external errors, the use of `.innerHTML` allows for input styling at this cost.\n// Supported types: success, info, warning\nexport function createAlert(type, message, alertVariables = [], timeout = 0) {\n    const domAlert = document.createElement('div');\n    domAlert.classList.add('alertpop');\n    domAlert.classList.add(type);\n    setTimeout(() => {\n        domAlert.style.opacity = '1';\n        domAlert.style.zIndex = '999999';\n        domAlert.classList.add('bounce-ani');\n        domAlert.classList.add('bounce');\n    }, 100);\n\n    // Maintainer QoL adjustment: if `alertVariables` is a number, it is instead assumed to be `timeout`\n    if (typeof alertVariables === 'number') {\n        timeout = alertVariables;\n        alertVariables = [];\n    }\n\n    // Apply translations\n    const translatedMessage = translateAlerts(message, alertVariables);\n\n    // Message\n    domAlert.innerHTML = translatedMessage;\n    domAlert.destroy = () => {\n        // Fully destroy timers + DOM elements, no memory leaks!\n        clearTimeout(domAlert.timer);\n        domAlert.style.opacity = '0';\n        setTimeout(() => {\n            domAlert.remove();\n        }, 600);\n    };\n    // On Click: Delete alert from DOM after close animation.\n    domAlert.addEventListener('click', domAlert.destroy);\n    // On Timeout: Delete alert from DOM after a period of inactive time.\n    if (timeout > 0) domAlert.timer = setTimeout(domAlert.destroy, timeout);\n    doms.domAlertPos.appendChild(domAlert);\n}\n\n// Shows the confirm modal with the provided html.\n// If resolvePromise has a value, the popup won't have\n// Confirm/Cancel buttons and will wait for the promise to resolve\n// Returns the awaited value of resolvePromise\n// or true/false if the user confirmed or not the modal\nexport async function confirmPopup({ title, html, resolvePromise }) {\n    // If there's a title provided: display the header and text\n    doms.domConfirmModalHeader.style.display = title ? 'block' : 'none';\n    doms.domConfirmModalTitle.innerHTML = title || '';\n\n    // If there's a promise to resolve, don't display buttons; the modal visibility will be controlled by the promise (f.e: a 'pls wait' screen)\n    doms.domConfirmModalButtons.style.setProperty(\n        'display',\n        resolvePromise ? 'none' : 'block',\n        resolvePromise ? 'important' : undefined\n    );\n    $('#confirmModal').modal(resolvePromise ? 'show' : { keyboard: false });\n\n    // Set content display\n    doms.domConfirmModalContent.innerHTML = html;\n\n    // If there's an input in the prompt, focus the cursor upon it\n    for (const domElement of doms.domConfirmModalContent.children) {\n        if (domElement.type === 'text' || domElement.type === 'password') {\n            domElement.focus();\n            break;\n        }\n    }\n\n    // Wait for the promise to resolve OR create a new one which resolves upon a modal button click\n    resolvePromise =\n        resolvePromise ||\n        new Promise((res, _) => {\n            doms.domConfirmModalConfirmButton.onclick = () => {\n                res(true);\n            };\n            doms.domConfirmModalCancelButton.onclick = () => {\n                res(false);\n            };\n        });\n    try {\n        return await resolvePromise;\n    } finally {\n        // We want to hide the modal even if an exception occurs\n        $('#confirmModal').modal('hide');\n    }\n}\n\n// Generates and sets a QRCode image from a string and dom element\nexport function createQR(strData = '', domImg, size = 4) {\n    // QRCode class consists of 'typeNumber' & 'errorCorrectionLevel'\n    const cQR = qrcode(size, 'L');\n    cQR.addData(strData);\n    cQR.make();\n    domImg.innerHTML = cQR.createImgTag(2, 2);\n    domImg.firstChild.style.borderRadius = '8px';\n}\n\n/**\n * Attempt to safely parse a BIP21 Payment Request\n * @param {string} strReq - BIP21 Payment Request string\n * @returns {object | false}\n */\nexport function parseBIP21Request(strReq) {\n    // Format should match: pivx:addr[?amount=x&label=x]\n    if (!strReq.includes(':')) return false;\n\n    const [addressPart, optionsPart] = strReq.includes('?') ? strReq.split('?') : [addressPart, false];\n    const strAddress = addressPart.substring(5); // remove 'pivx:' prefix\n    let cOptions = {};\n\n    if (optionsPart) {\n      cOptions = Object.fromEntries(\n        optionsPart.split('&').map(opt => opt.split('=').map(decodeURIComponent))\n      );\n    }\n\n    return {strAddress, cOptions};\n}\n\n//generate private key for masternodes\nexport async function generateMnPrivkey() {\n    // maximum value for a decoded private key\n    let max_decoded_value =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337n;\n    let valid = false;\n    let priv_key = 0;\n    while (!valid) {\n        priv_key = bytesToHex(getSafeRand(32));\n        let decoded_priv_key = BigInt('0x' + priv_key);\n\n        if (0 < decoded_priv_key && decoded_priv_key < max_decoded_value) {\n            valid = true;\n        }\n    }\n    return await convertMnPrivKeyFromHex(priv_key);\n}\n\nexport async function convertMnPrivKeyFromHex(hexStr) {\n    //prefixes\n    let WIF_PREFIX = 212;\n    let TESTNET_WIF_PREFIX = 239;\n    let base58_secret = cChainParams.current.isTestnet\n        ? TESTNET_WIF_PREFIX\n        : WIF_PREFIX;\n\n    //convert the hexStr+ initial prefix to byte array hexToBytes(string)\n    let data = [...hexToBytes(hexStr)];\n    data.unshift(base58_secret);\n\n    //generate the checksum with double sha256 hashing\n    let checksum = hexToBytes(await hash(hexToBytes(await hash(data)))).slice(\n        0,\n        4\n    );\n\n    //concatenate data and checksum\n    for (const byte of checksum) {\n        data.push(byte);\n    }\n\n    return bs58.encode(data);\n}\n\n//sha256 a bytearray and return the hash in hexadecimal\nexport async function hash(byteArray) {\n    const utf8 = new Uint8Array(byteArray);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', utf8);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray\n        .map((bytes) => bytes.toString(16).padStart(2, '0'))\n        .join('');\n    return hashHex;\n}\n\nexport function sanitizeHTML(text) {\n    const element = document.createElement('div');\n    element.innerText = text;\n    return element.innerHTML;\n}\n\n/**\n * An artificial sleep function to pause code execution\n *\n * @param {Number} ms - The milliseconds to sleep\n *\n * @example\n * // Pause an asynchronous script for 1 second\n * await sleep(1000);\n */\nexport function sleep(ms) {\n    return new Promise((res, _) => setTimeout(res, ms));\n}\n","import { en_translation } from '../locale/en/translation.js';\nimport { uwu_translation } from '../locale/uwu/translation.js';\n\nexport const ALERTS = {};\nexport let translation = {};\n\n// TRANSLATION\n//Create an object of objects filled with all the translations\nexport const translatableLanguages = {\n    en: en_translation,\n    uwu: uwu_translation,\n};\n\n/**\n * Takes the language name and sets the translation settings based on the language file\n * @param {string} langName\n */\nexport function switchTranslation(langName) {\n    if (arrActiveLangs.includes(langName)) {\n        translation = translatableLanguages[langName];\n        translate(translation);\n        loadAlerts();\n        return true;\n    } else {\n        console.log(\n            'i18n: The language (' +\n                langName +\n                \") is not supported yet, if you'd like to contribute translations (for rewards!) contact us on GitHub or Discord!\"\n        );\n        translation = translatableLanguages.en_translation;\n        return false;\n    }\n}\n\n/**\n * Takes a string that includes {x} and replaces that based on what is in the array of objects\n * @param {string} message\n * @param {array<Object>} variables\n * @returns a string with the variables implemented in the string\n *\n * @example\n * //returns \"test this\"\n * translateAlerts(\"test {x}\" [x : \"this\"])\n */\nexport function translateAlerts(message, variables) {\n    variables.forEach((element) => {\n        message = message.replaceAll(\n            '{' + Object.keys(element)[0] + '}',\n            Object.values(element)[0]\n        );\n    });\n    return message;\n}\n\n/**\n * Translates all the static html based on the tag data-i18n\n * @param {Array} i18nLangs\n *\n */\nexport function translate(i18nLangs) {\n    if (!i18nLangs) return;\n\n    document.querySelectorAll('[data-i18n]').forEach(function (element) {\n        if (!i18nLangs[element.dataset.i18n]) return;\n\n        if (element.dataset.i18n_target) {\n            element[element.dataset.i18n_target] =\n                i18nLangs[element.dataset.i18n];\n        } else {\n            switch (element.tagName.toLowerCase()) {\n                case 'input':\n                case 'textarea':\n                    element.placeholder = i18nLangs[element.dataset.i18n];\n                    break;\n                default:\n                    element.innerHTML = i18nLangs[element.dataset.i18n];\n                    break;\n            }\n        }\n    });\n    loadAlerts();\n}\n\n/**\n * Translates the alerts by loading the data into the ALERTS object\n */\nexport function loadAlerts() {\n    // Alerts are designated by a special 'ALERTS' entry in each translation file\n    let fFoundAlerts = false;\n    for (const [alert_key, alert_translation] of Object.entries(translation)) {\n        if (fFoundAlerts) {\n            ALERTS[alert_key] = alert_translation;\n        }\n        // Skip all entries until we find the ALERTS flag\n        if (alert_key === 'ALERTS') fFoundAlerts = true;\n    }\n}\nfunction parseUserAgentLang(strUA, arrLangsWithSubset) {\n    if (arrLangsWithSubset.some((strLang) => strUA.includes(strLang))) {\n        // Split the lang in to 'primary' and 'subset', only use the primary lang\n        return strUA.substring(0, 2);\n    }\n    // Otherwise, just use the full language spec\n    return strUA;\n}\n\n// When adding a lang remember to add it to the object translatableLanguages as well as here.\nexport const arrActiveLangs = ['en', 'uwu'];\n\nexport function start() {\n    // We use this function to parse the UA lang in a safer way: for example, there's multiple `en` definitions\n    // ... but we shouldn't duplicate the language files, we can instead cut the affix (US, GB) and simply use 'en'.\n    // ... This logic may apply to other languages with such subsets as well, so take care of them here!\n    const arrLangsWithSubset = ['en'];\n\n    const strLang = parseUserAgentLang(\n        window.navigator.userLanguage || window.navigator.language,\n        arrLangsWithSubset\n    );\n\n    // When removing you do not have to remove from translatableLanguages\n    let localTranslation = localStorage.getItem('translation');\n    // Check if set in local storage\n    if (localTranslation != null) {\n        switchTranslation(localTranslation);\n    } else {\n        // Check if we support the user's browser locale\n        if (arrActiveLangs.includes(strLang)) {\n            switchTranslation(strLang);\n        } else {\n            // Default to EN if the locale isn't supported yet\n            console.log(\n                'i18n: Your language (' +\n                    strLang +\n                    \") is not supported yet, if you'd like to contribute translations (for rewards!) contact us on GitHub or Discord!\"\n            );\n            switchTranslation('en');\n        }\n    }\n    translate(translation);\n}\n","import { EventEmitter } from 'events';\n\nconst eventEmitter = new EventEmitter();\n\n/**\n * Get the application wide event emitter.\n * @returns {EventEmitter}\n */\nexport function getEventEmitter() {\n    return eventEmitter;\n}\n","import { getBalance } from './global';\nimport { cMarket, fillCurrencySelect } from './settings';\n\n/**\n * CoinGecko's endpoint for PIVX data, optimised for least bandwidth\n * - No localisation, tickers, community data, developer data or sparklines\n */\nexport const COINGECKO_ENDPOINT =\n    'https://api.coingecko.com/api/v3/coins/pivx?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false';\n\n/**\n * The generic market data source template, used to build site-specific classes\n */\nexport class MarketSource {\n    /** The storage object for raw market data */\n    cData = {};\n\n    /** The name of the market source */\n    strName = '';\n\n    /** The customised API endpoint of the market source */\n    strEndpoint = '';\n\n    /**\n     * Ensure a market data cache exists, if not, fetch it and resume\n     */\n    async ensureCacheExists() {\n        if (!this.cData || !Object.keys(this.cData).length) await this.fetch();\n    }\n\n    /**\n     * Fetches the raw market source data\n     * @returns {Promise<object>}\n     */\n    async fetch() {\n        return (this.cData = await (await fetch(this.strEndpoint)).json());\n    }\n}\n\n/**\n * The CoinGecko market data source\n */\nexport class CoinGecko extends MarketSource {\n    constructor() {\n        super();\n        this.strName = 'CoinGecko';\n        this.strEndpoint = COINGECKO_ENDPOINT;\n    }\n\n    /**\n     * Get the price in a specific display currency\n     * @param {string} strCurrency - The CoinGecko-supported display currency\n     * @return {Promise<number>}\n     */\n    async getPrice(strCurrency) {\n        await this.ensureCacheExists();\n        return this.cData.market_data.current_price[strCurrency];\n    }\n\n    /**\n     * Get a list of the supported display currencies\n     * @returns {Promise<Array<string>>} - A list of CoinGecko-supported display currencies\n     */\n    async getCurrencies() {\n        await this.ensureCacheExists();\n        return Object.keys(this.cData.market_data.current_price);\n    }\n}\n\n/**\n * Refreshes market data from the user's data source, then re-renders currency options and price displays\n */\nexport async function refreshPriceDisplay() {\n    // Refresh our price data\n    await cMarket.fetch();\n\n    // Update the currency customisation menu from the selected data source\n    await fillCurrencySelect();\n\n    // Update price values\n    getBalance(true);\n}\n","import {\n    doms,\n    getBalance,\n    getStakingBalance,\n    updateStakingRewardsGUI,\n} from './global.js';\nimport { fWalletLoaded, masterKey } from './wallet.js';\nimport { cChainParams } from './chain_params.js';\nimport { setNetwork, ExplorerNetwork, getNetwork } from './network.js';\nimport { createAlert } from './misc.js';\nimport {\n    switchTranslation,\n    ALERTS,\n    translation,\n    arrActiveLangs,\n} from './i18n.js';\nimport { CoinGecko } from './prices.js';\n\n// --- Default Settings\n/** A mode that emits verbose console info for internal MPW operations */\nexport let debug = false;\n/**\n * The user-selected display currency from market-aggregator sites\n * @type {string}\n */\nexport let strCurrency = 'usd';\n/**\n * The global market data source\n * @type {CoinGecko}\n */\nexport let cMarket = new CoinGecko();\n/** The user-selected explorer, used for most of MPW's data synchronisation */\nexport let cExplorer = cChainParams.current.Explorers[0];\n/** The user-selected MPW node, used for alternative blockchain data */\nexport let cNode = cChainParams.current.Nodes[0];\n\nlet transparencyReport;\n// A list of statistic keys and their descriptions\nexport let STATS = {\n    // Stat key   // Description of the stat, it's data, and it's purpose\n    hit: 'A ping indicating an app load, no unique data is sent.',\n    time_to_sync: 'The time in seconds it took for MPW to last synchronise.',\n    transaction:\n        'A ping indicating a Tx, no unique data is sent, but may be inferred from on-chain time.',\n};\n\nexport const cStatKeys = Object.keys(STATS);\n\n// A list of Analytics 'levels' at which the user may set depending on their privacy preferences\nlet arrAnalytics = [\n    // Statistic level  // Allowed statistics\n    { name: 'Disabled', stats: [] },\n    { name: 'Minimal', stats: [STATS.hit, STATS.time_to_sync] },\n    {\n        name: 'Balanced',\n        stats: [STATS.hit, STATS.time_to_sync, STATS.transaction],\n    },\n];\n\nexport let cAnalyticsLevel = arrAnalytics[2];\n\n// Users need not look below here.\n// ------------------------------\n// Global Keystore / Wallet Information\n\n// --- DOM Cache\nexport function start() {\n    //TRANSLATIONS\n    //to make translations work we need to change it so that we just enable or disable the visibility of the text\n    doms.domTestnet.style.display = cChainParams.current.isTestnet\n        ? ''\n        : 'none';\n    doms.domDebug.style.display = debug ? '' : 'none';\n\n    // Hook up the 'currency' select UI\n    document.getElementById('currency').onchange = function (evt) {\n        setCurrency(evt.target.value);\n    };\n\n    // Hook up the 'explorer' select UI\n    document.getElementById('explorer').onchange = function (evt) {\n        setExplorer(\n            cChainParams.current.Explorers.find(\n                (a) => a.url === evt.target.value\n            )\n        );\n    };\n\n    // Hook up the 'translation' select UI\n    document.getElementById('translation').onchange = function (evt) {\n        setTranslation(evt.target.value);\n    };\n\n    // Hook up the 'analytics' select UI\n    document.getElementById('analytics').onchange = function (evt) {\n        setAnalytics(arrAnalytics.find((a) => a.name === evt.target.value));\n    };\n\n    fillExplorerSelect();\n    fillNodeSelect();\n    fillTranslationSelect();\n\n    // Fill all selection UIs with their options\n    if (getNetwork().enabled) {\n        fillCurrencySelect();\n    }\n\n    // Add each analytics level into the UI selector\n    const domAnalyticsSelect = document.getElementById('analytics');\n    for (const analLevel of arrAnalytics) {\n        const opt = document.createElement('option');\n        opt.value = opt.innerHTML = analLevel.name;\n        domAnalyticsSelect.appendChild(opt);\n    }\n\n    // Fetch settings from LocalStorage\n    const strSettingAnalytics = localStorage.getItem('analytics');\n\n    // Apply translations to the transparency report\n    STATS = {\n        // Stat key   // Description of the stat, it's data, and it's purpose\n        hit: translation.hit,\n        time_to_sync: translation.time_to_sync,\n        transaction: translation.transaction,\n    };\n    transparencyReport = translation.transparencyReport;\n    arrAnalytics = [\n        // Statistic level  // Allowed statistics\n        { name: 'Disabled', stats: [] },\n        { name: 'Minimal', stats: [STATS.hit, STATS.time_to_sync] },\n        {\n            name: 'Balanced',\n            stats: [STATS.hit, STATS.time_to_sync, STATS.transaction],\n        },\n    ];\n\n    // Initialise status icons as their default variables\n    doms.domNetwork.innerHTML =\n        '<i class=\"fa-solid fa-' +\n        (getNetwork().enabled ? 'wifi' : 'ban') +\n        '\"></i>';\n\n    // Honour the \"Do Not Track\" header by default\n    if (!strSettingAnalytics && navigator.doNotTrack === '1') {\n        // Disabled\n        setAnalytics(arrAnalytics[0], true);\n        doms.domAnalyticsDescriptor.innerHTML =\n            '<h6 style=\"color:#dcdf6b;font-family:mono !important;\"><pre style=\"color: inherit;\">Analytics disabled to honour \"Do Not Track\" browser setting, you may manually enable if desired, though!</pre></h6>';\n    } else {\n        // Load from storage, or use defaults\n        setAnalytics(\n            (cAnalyticsLevel =\n                arrAnalytics.find((a) => a.name === strSettingAnalytics) ||\n                cAnalyticsLevel),\n            true\n        );\n    }\n\n    // And update the UI to reflect them\n    domAnalyticsSelect.value = cAnalyticsLevel.name;\n}\n// --- Settings Functions\nfunction setExplorer(explorer, fSilent = false) {\n    cExplorer = explorer;\n    localStorage.setItem(\n        'explorer' + (cChainParams.current.isTestnet ? '-testnet' : ''),\n        explorer.url\n    );\n\n    // Enable networking + notify if allowed\n    const network = new ExplorerNetwork(cExplorer.url, masterKey);\n    setNetwork(network);\n\n    if (!fSilent)\n        createAlert(\n            'success',\n            ALERTS.SWITCHED_EXPLORERS,\n            [{ explorerName: cExplorer.name }],\n            2250\n        );\n}\n\nfunction setNode(node, fSilent = false) {\n    cNode = node;\n    localStorage.setItem(\n        'node' + (cChainParams.current.isTestnet ? '-testnet' : ''),\n        node.url\n    );\n\n    // Enable networking + notify if allowed\n    getNetwork().enable();\n    if (!fSilent)\n        createAlert(\n            'success',\n            ALERTS.SWITCHED_NODE,\n            [{ node: cNode.name }],\n            2250\n        );\n}\n\n//TRANSLATION\n/**\n * Switches the translation and sets the translation preference to local storage\n * @param {string} lang\n * @param {bool} fSilent\n */\nfunction setTranslation(lang) {\n    switchTranslation(lang);\n    localStorage.setItem('translation', lang);\n}\n\n/**\n * Sets and saves the display currency setting in runtime and localStorage\n * @param {string} currency - The currency string name\n */\nfunction setCurrency(currency) {\n    strCurrency = currency;\n    localStorage.setItem('displayCurrency', strCurrency);\n    // Update the UI to reflect the new currency\n    getBalance(true);\n}\n\n/**\n * Fills the translation dropbox on the settings page\n */\nfunction fillTranslationSelect() {\n    while (doms.domTranslationSelect.options.length > 0) {\n        doms.domTranslationSelect.remove(0);\n    }\n\n    // Add each trusted explorer into the UI selector\n    for (const lang of arrActiveLangs) {\n        const opt = document.createElement('option');\n        opt.innerHTML = opt.value = lang;\n        doms.domTranslationSelect.appendChild(opt);\n    }\n\n    // And update the UI to reflect them\n    doms.domTranslationSelect.value =\n        localStorage.getItem('translation') || 'en';\n}\n\n/**\n * Fills the display currency dropbox on the settings page\n */\nexport async function fillCurrencySelect() {\n    while (doms.domCurrencySelect.options.length > 0) {\n        doms.domCurrencySelect.remove(0);\n    }\n\n    // Add each data source currency into the UI selector\n    for (const currency of await cMarket.getCurrencies()) {\n        const opt = document.createElement('option');\n        opt.innerHTML = currency.toUpperCase();\n        opt.value = currency;\n        doms.domCurrencySelect.appendChild(opt);\n    }\n\n    // And update the UI to reflect them\n    strCurrency = doms.domCurrencySelect.value =\n        localStorage.getItem('displayCurrency') || strCurrency;\n}\n\nfunction setAnalytics(level, fSilent = false) {\n    cAnalyticsLevel = level;\n    localStorage.setItem('analytics', level.name);\n    // For total transparency, we'll 'describe' the various analytic keys of this chosen level\n    let strDesc = '<center>--- ' + transparencyReport + ' ---</center><br>',\n        i = 0;\n    const nLongestKeyLen = cStatKeys.reduce((prev, e) =>\n        prev.length >= e.length ? prev : e\n    ).length;\n    for (i; i < cAnalyticsLevel.stats.length; i++) {\n        const cStat = cAnalyticsLevel.stats[i];\n        // This formats Stat keys into { $key $(padding) $description }\n        strDesc +=\n            cStatKeys\n                .find((a) => STATS[a] === cStat)\n                .padEnd(nLongestKeyLen, ' ') +\n            ': ' +\n            cStat +\n            '<br>';\n    }\n\n    // Set display + notify if allowed\n    doms.domAnalyticsDescriptor.innerHTML =\n        cAnalyticsLevel.name === arrAnalytics[0].name\n            ? ''\n            : '<h6 style=\"color:#dcdf6b;font-family:mono !important;\"><pre style=\"color: inherit;\">' +\n              strDesc +\n              '</pre></h6>';\n    if (!fSilent)\n        createAlert(\n            'success',\n            ALERTS.SWITCHED_ANALYTICS,\n            [{ level: cAnalyticsLevel.name }],\n            2250\n        );\n}\n\nexport function toggleTestnet() {\n    if (fWalletLoaded)\n        return createAlert('warning', ALERTS.UNABLE_SWITCH_TESTNET, [], 3250);\n\n    // Update current chain config\n    cChainParams.current = cChainParams.current.isTestnet\n        ? cChainParams.main\n        : cChainParams.testnet;\n\n    // Update UI and static tickers\n    //TRANSLATIONS\n    doms.domTestnet.style.display = cChainParams.current.isTestnet\n        ? ''\n        : 'none';\n    doms.domGuiBalanceTicker.innerText = cChainParams.current.TICKER;\n    doms.domGuiBalanceStakingTicker.innerText = cChainParams.current.TICKER;\n    doms.domPrefixNetwork.innerText =\n        cChainParams.current.PUBKEY_PREFIX.join(' or ');\n    fillExplorerSelect();\n    fillNodeSelect();\n    getBalance(true);\n    getStakingBalance(true);\n    updateStakingRewardsGUI();\n}\n\nexport function toggleDebug() {\n    debug = !debug;\n    doms.domDebug.style.display = debug ? '' : 'none';\n}\n\nfunction fillExplorerSelect() {\n    cExplorer = cChainParams.current.Explorers[0];\n\n    while (doms.domExplorerSelect.options.length > 0) {\n        doms.domExplorerSelect.remove(0);\n    }\n\n    // Add each trusted explorer into the UI selector\n    for (const explorer of cChainParams.current.Explorers) {\n        const opt = document.createElement('option');\n        opt.value = explorer.url;\n        opt.innerHTML =\n            explorer.name + ' (' + explorer.url.replace('https://', '') + ')';\n        doms.domExplorerSelect.appendChild(opt);\n    }\n\n    // Fetch settings from LocalStorage\n    const strSettingExplorer = localStorage.getItem(\n        'explorer' + (cChainParams.current.isTestnet ? '-testnet' : '')\n    );\n\n    // For any that exist: load them, or use the defaults\n    setExplorer(\n        cChainParams.current.Explorers.find(\n            (a) => a.url === strSettingExplorer\n        ) || cExplorer,\n        true\n    );\n\n    // And update the UI to reflect them\n    doms.domExplorerSelect.value = cExplorer.url;\n}\n\nfunction fillNodeSelect() {\n    cNode = cChainParams.current.Nodes[0];\n\n    while (doms.domNodeSelect.options.length > 0) {\n        doms.domNodeSelect.remove(0);\n    }\n\n    // Add each trusted node into the UI selector\n    for (const node of cChainParams.current.Nodes) {\n        const opt = document.createElement('option');\n        opt.value = node.url;\n        opt.innerHTML =\n            node.name + ' (' + node.url.replace('https://', '') + ')';\n        doms.domNodeSelect.appendChild(opt);\n    }\n\n    // Fetch settings from LocalStorage\n    const strSettingNode = localStorage.getItem(\n        'node' + (cChainParams.current.isTestnet ? '-testnet' : '')\n    );\n\n    // For any that exist: load them, or use the defaults\n    setNode(\n        cChainParams.current.Nodes.find((a) => a.url === strSettingNode) ||\n            cNode,\n        true\n    );\n\n    // And update the UI to reflect them\n    doms.domNodeSelect.value = cNode.url;\n}\n","import { getNetwork } from './network.js';\nimport { getBalance, isMasternodeUTXO, getStakingBalance } from './global.js';\nimport { sleep } from './misc.js';\nimport { debug } from './settings.js';\nimport { getEventEmitter } from './event_bus.js';\n\n/** An Unspent Transaction Output, used as Inputs of future transactions */\nexport class UTXO {\n    /**\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {String} UTXO.path - If applicable, the HD Path of the owning address\n     * @param {Number} UTXO.sats - Satoshi value in this UTXO\n     * @param {String} UTXO.script - HEX encoded spending script\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} UTXO.height - Block height of the UTXO\n     * @param {Number} UTXO.status - UTXO status enum state\n     * @param {bool} UTXO.isDelegate - Whether the UTXO is a cold stake delegation\n     */\n    constructor({\n        id,\n        path,\n        sats,\n        script,\n        vout,\n        height,\n        status,\n        isDelegate = false,\n        isReward = false,\n    } = {}) {\n        /** Transaction ID\n         * @type {String} */\n        this.id = id;\n\n        /** HD Path of the owning address\n         *  @type {String} */\n        this.path = path;\n\n        /** Satoshi value in this UTXO\n         *  @type {Number} */\n        this.sats = sats;\n\n        /** HEX encoded spending script\n         *  @type {String} */\n        this.script = script;\n\n        /** Output position of this transaction\n         *  @type {Number} */\n        this.vout = vout;\n\n        /** Block height of the UTXO\n         *  @type {Number} */\n        this.height = height;\n\n        /** UTXO status enum state\n         *  @type {Number} */\n        this.status = status;\n\n        /** If it's a delegation UTXO\n         * @type {bool} */\n        this.isDelegate = isDelegate;\n\n        this.isReward = isReward;\n    }\n\n    /**\n     * Check for equality between this UTXO and another UTXO\n     * @param {UTXO} cUTXO - UTXO to compare against\n     * @returns {Boolean} `true` if equal, `false` if unequal\n     */\n    equalsUTXO(cUTXO) {\n        return (\n            this.id === cUTXO.id &&\n            this.vout === cUTXO.vout &&\n            this.status === cUTXO.status\n        );\n    }\n}\n\n/** A Mempool instance, stores and handles UTXO data for the wallet */\nexport class Mempool {\n    constructor() {\n        /**\n         * An array of all known UTXOs\n         * @type {Array<UTXO>}\n         */\n        this.UTXOs = [];\n        this.subscribeToNetwork();\n    }\n\n    /** The CONFIRMED state (UTXO is spendable) */\n    static CONFIRMED = 0;\n\n    /** The REMOVED state (UTXO was spent and will be removed soon) */\n    static REMOVED = 1;\n\n    /** The PENDING state (standard UTXO is in mempool, pending confirmation) */\n    static PENDING = 2;\n\n    /**\n     * Remove a UTXO after a set amount of time\n     * @param {Number} nBlocks - Estimated blocks to wait\n     * @param {UTXO} cUTXO - UTXO to remove\n     */\n    async removeWithDelay(nBlocks, cUTXO) {\n        await sleep(nBlocks * 60 * 1000);\n        this.removeUTXO(cUTXO);\n    }\n\n    /**\n     * Check if an exact UTXO match can be found in our wallet\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} [UTXO.status] - UTXO status enum state. If it's undefined, it will ignore it.\n     * @returns {Boolean} `true` or `false`\n     */\n    isAlreadyStored({ id, vout, status }) {\n        return this.UTXOs.some(\n            (cUTXO) =>\n                cUTXO.id === id &&\n                cUTXO.vout === vout &&\n                (!status || cUTXO.status === status)\n        );\n    }\n\n    /**\n     * Fetches an array of UTXOs filtered by their state\n     * @param {Number} nState - Specific UTXO state\n     * @returns {Array<UTXO>} `array` - An array of UTXOs\n     */\n    getUTXOsByState(nState) {\n        return this.UTXOs.filter((cUTXO) => cUTXO.status === nState);\n    }\n\n    /**\n     * Removes a UTXO from a specific state\n     * @param {UTXO} cNewUTXO - Pending UTXO to remove\n     * @param {Number} nState - Specific state of this UTXO to search for\n     */\n    removeFromState(cNewUTXO, nState) {\n        const arrPendingUTXOs = this.getUTXOsByState(nState);\n        // Loop each pending UTXO\n        for (const cUTXO of arrPendingUTXOs) {\n            // Search for matching ID + output number\n            if (cUTXO.id === cNewUTXO.id && cUTXO.vout === cNewUTXO.vout) {\n                // Nuke it from orbit\n                this.removeUTXO(cUTXO);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Add a new UTXO to the wallet\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {String} UTXO.path - If applicable, the HD Path of the owning address\n     * @param {Number} UTXO.sats - Satoshi value in this UTXO\n     * @param {String} UTXO.script - HEX encoded spending script\n     * @param {Number} UTXO.vout - Output position of this transaction\n     * @param {Number} UTXO.height - Block height of the UTXO\n     * @param {Number} UTXO.status - UTXO status enum state\n     * @param {Boolean} UTXO.isDelegate - If this is a Cold Delegation\n     */\n    addUTXO({\n        id,\n        path,\n        sats,\n        script,\n        vout,\n        height,\n        status,\n        isDelegate,\n        isReward,\n    }) {\n        const newUTXO = new UTXO({\n            id,\n            path,\n            sats,\n            script,\n            vout,\n            height,\n            status,\n            isDelegate,\n            isReward,\n        });\n\n        if (this.isAlreadyStored({ id, vout })) {\n            this.updateUTXO({ id, vout });\n        } else {\n            this.UTXOs.push(newUTXO);\n        }\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    /**\n     * Update an existing UTXO, by confirming its pending status\n     * The UTXO must be in\n     * @param {Object} UTXO - Object to be deconstructed\n     * @param {String} UTXO.id - Transaction id\n     * @param {Number} UTXO.vout - vout\n     */\n    updateUTXO({ id, vout }) {\n        if (debug) {\n            console.assert(\n                this.isAlreadyStored({ id, vout }),\n                'updateUTXO must be called with an existing UTXO'\n            );\n        }\n        const cUTXO = this.UTXOs.find(\n            (utxo) => utxo.id === id && utxo.vout == vout\n        );\n        switch (cUTXO.status) {\n            case Mempool.PENDING:\n                cUTXO.status = Mempool.CONFIRMED;\n                break;\n        }\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    /**\n     * Remove a UTXO completely from our wallet\n     * @param {UTXO} cUTXO - UTXO to remove\n     */\n    removeUTXO(cUTXO) {\n        this.UTXOs = this.UTXOs.filter((utxo) => !utxo.equalsUTXO(cUTXO));\n    }\n\n    /**\n     * Remove a UTXO completely from our wallet, with a 12 minute delay given his id, path and vout\n     * @param {Object} UTXO\n     * @param {String} UTXO.id - Transaction ID\n     * @param {Number} UTXO.vout - Output position of this transaction\n     */\n    autoRemoveUTXO({ id, vout }) {\n        for (const cUTXO of this.UTXOs) {\n            // Loop given + internal UTXOs to find a match, then start the delayed removal\n            if (cUTXO.id === id && cUTXO.vout === vout) {\n                cUTXO.status = Mempool.REMOVED;\n                this.removeWithDelay(12, cUTXO);\n                return;\n            }\n        }\n        console.error(\n            'Mempool: Failed to find UTXO ' +\n                id +\n                ' (' +\n                vout +\n                ') for auto-removal!'\n        );\n    }\n\n    /**\n     * Remove many UTXOs completely from our wallet, with a 12 minute delay\n     * @param {Array<UTXO>} arrUTXOs - UTXOs to remove\n     */\n    autoRemoveUTXOs(arrUTXOs) {\n        for (const cNewUTXO of arrUTXOs) {\n            for (const cUTXO of this.UTXOs) {\n                // Loop given + internal UTXOs to find a match, then start the delayed removal\n                if (cUTXO.equalsUTXO(cNewUTXO)) {\n                    cUTXO.status = Mempool.REMOVED;\n                    this.removeWithDelay(12, cUTXO);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Fetches an array of confirmed UTXOs, an easier alias to {@link getUTXOsByState}\n     * @returns {Array<UTXO>} `array` - An array of UTXOs\n     */\n    getConfirmed() {\n        return this.getUTXOsByState(Mempool.CONFIRMED);\n    }\n\n    /**\n     * Get standard, non delegated, UTXOs\n     * @returns {Array<UTXO>} Non delegated utxos\n     */\n    getStandardUTXOs() {\n        return this.UTXOs.filter(\n            (cUTXO) => cUTXO.status !== Mempool.REMOVED && !cUTXO.isDelegate\n        );\n    }\n\n    /**\n     * Get delegated UTXOs\n     * @returns {Array<UTXO>} Delegated UTXOs\n     */\n    getDelegatedUTXOs() {\n        return this.UTXOs.filter(\n            (cUTXO) => cUTXO.status !== Mempool.REMOVED && cUTXO.isDelegate\n        );\n    }\n\n    /**\n     * Returns the real-time balance of the wallet (all addresses)\n     * @returns {Number} Balance in satoshis\n     */\n    getBalance() {\n        // Fetch 'standard' balances: the sum of all Confirmed or Unconfirmed transactions (excluding Masternode collaterals)\n        return this.getStandardUTXOs()\n            .filter((cUTXO) => !isMasternodeUTXO(cUTXO))\n            .reduce((a, b) => a + b.sats, 0);\n    }\n\n    /**\n     * Returns if a UTXO is valid\n     * @param {UTXO} cUTXO - UTXO\n     * @returns {Boolean} `true` if the reward UTXO is spendable, `false` if not\n     */\n    static isValidUTXO(cUTXO) {\n        if (cUTXO.isReward) {\n            return getNetwork().cachedBlockCount - cUTXO.height > 100;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Returns the real-time delegated balance of the wallet (all addresses)\n     * @returns {Number} Delegated balance in satoshis\n     */\n    getDelegatedBalance() {\n        return this.getDelegatedUTXOs().reduce((a, b) => a + b.sats, 0);\n    }\n\n    /**\n     * Subscribes to network events\n     * @param {Network} network\n     */\n    subscribeToNetwork() {\n        getEventEmitter().on('utxo', async (utxos) => {\n            for (const utxo of utxos) {\n                if (this.isAlreadyStored({ id: utxo.txid, vout: utxo.vout })) {\n                    this.updateUTXO({ id: utxo.txid, vout: utxo.vout });\n                    continue;\n                }\n                this.addUTXO(await getNetwork().getUTXOFullInfo(utxo));\n            }\n        });\n    }\n}\n","import { Mempool } from './mempool.js';\nimport Masternode from './masternode.js';\nimport { ALERTS, start as i18nStart, translation } from './i18n.js';\nimport * as jdenticon from 'jdenticon';\nimport {\n    masterKey,\n    hasEncryptedWallet,\n    importWallet,\n    encryptWallet,\n    decryptWallet,\n    getDerivationPath,\n} from './wallet.js';\nimport { getNetwork } from './network.js';\nimport {\n    start as settingsStart,\n    cExplorer,\n    debug,\n    cMarket,\n    strCurrency,\n} from './settings.js';\nimport { createAlert, confirmPopup, sanitizeHTML, MAP_B58, parseBIP21Request } from './misc.js';\nimport { cChainParams, COIN, MIN_PASS_LENGTH } from './chain_params.js';\nimport { decrypt } from './aes-gcm.js';\n\nimport { registerWorker } from './native.js';\nimport { refreshPriceDisplay } from './prices.js';\nimport { Address6 } from 'ip-address';\nimport { getEventEmitter } from './event_bus.js';\nimport { scanQRCode } from './scanner.js';\n\nexport let doms = {};\n\nexport function start() {\n    doms = {\n        domNavbarToggler: document.getElementById('navbarToggler'),\n        domDashboard: document.getElementById('dashboard'),\n        domGuiStaking: document.getElementById('guiStaking'),\n        domGuiWallet: document.getElementById('guiWallet'),\n        domGuiBalance: document.getElementById('guiBalance'),\n        domGuiBalanceTicker: document.getElementById('guiBalanceTicker'),\n        domGuiBalanceValue: document.getElementById('guiBalanceValue'),\n        domGuiBalanceValueCurrency: document.getElementById(\n            'guiBalanceValueCurrency'\n        ),\n        domGuiBalanceBox: document.getElementById('guiBalanceBox'),\n        domBalanceReload: document.getElementById('balanceReload'),\n        domBalanceReloadStaking: document.getElementById(\n            'balanceReloadStaking'\n        ),\n        domGuiBalanceStaking: document.getElementById('guiBalanceStaking'),\n        domGuiBalanceStakingTicker: document.getElementById(\n            'guiBalanceStakingTicker'\n        ),\n        domGuiStakingLoadMore: document.getElementById('stakingLoadMore'),\n        domGuiStakingLoadMoreIcon: document.getElementById(\n            'stakingLoadMoreIcon'\n        ),\n        domGuiBalanceBoxStaking: document.getElementById(\n            'guiBalanceBoxStaking'\n        ),\n        domGuiDelegateAmount: document.getElementById('delegateAmount'),\n        domGuiUndelegateAmount: document.getElementById('undelegateAmount'),\n        domStakeTab: document.getElementById('stakeTab'),\n        domAddress1s: document.getElementById('address1s'),\n        domSendAmountCoins: document.getElementById('sendAmountCoins'),\n        domSendAmountCoinsTicker: document.getElementById(\n            'sendAmountCoinsTicker'\n        ),\n        domSendAmountValue: document.getElementById('sendAmountValue'),\n        domSendAmountValueCurrency: document.getElementById(\n            'sendAmountValueCurrency'\n        ),\n        domGuiViewKey: document.getElementById('guiViewKey'),\n        domModalQR: document.getElementById('ModalQR'),\n        domModalQrLabel: document.getElementById('ModalQRLabel'),\n        domModalQRReader: document.getElementById('qrReaderModal'),\n        domQrReaderStream: document.getElementById('qrReaderStream'),\n        domCloseQrReaderBtn: document.getElementById('closeQrReader'),\n        domPrefix: document.getElementById('prefix'),\n        domPrefixNetwork: document.getElementById('prefixNetwork'),\n        domWalletToggle: document.getElementById('wToggle'),\n        domGenerateWallet: document.getElementById('generateWallet'),\n        domGenVanityWallet: document.getElementById('generateVanityWallet'),\n        domGenHardwareWallet: document.getElementById('generateHardwareWallet'),\n        //GOVERNANCE ELEMENTS\n        domGovProposalsTable: document.getElementById('proposalsTable'),\n        domGovProposalsTableBody: document.getElementById('proposalsTableBody'),\n        domGovProposalsContestedTable: document.getElementById(\n            'proposalsContestedTable'\n        ),\n        domGovProposalsContestedTableBody: document.getElementById(\n            'proposalsContestedTableBody'\n        ),\n        //MASTERNODE ELEMENTS\n        domCreateMasternode: document.getElementById('createMasternode'),\n        domControlMasternode: document.getElementById('controlMasternode'),\n        domAccessMasternode: document.getElementById('accessMasternode'),\n        domMnAccessMasternodeText: document.getElementById(\n            'accessMasternodeText'\n        ),\n        domMnCreateType: document.getElementById('mnCreateType'),\n        domMnTextErrors: document.getElementById('mnTextErrors'),\n        domMnIP: document.getElementById('mnIP'),\n        domMnTxId: document.getElementById('mnTxId'),\n        domMnPrivateKey: document.getElementById('mnPrivateKey'),\n        domMnDashboard: document.getElementById('mnDashboard'),\n        domMnProtocol: document.getElementById('mnProtocol'),\n        domMnStatus: document.getElementById('mnStatus'),\n        domMnNetType: document.getElementById('mnNetType'),\n        domMnNetIP: document.getElementById('mnNetIP'),\n        domMnLastSeen: document.getElementById('mnLastSeen'),\n\n        domAccessWallet: document.getElementById('accessWallet'),\n        domImportWallet: document.getElementById('importWallet'),\n        domImportWalletText: document.getElementById('importWalletText'),\n        domAccessWalletBtn: document.getElementById('accessWalletBtn'),\n        domVanityUiButtonTxt: document.getElementById('vanButtonText'),\n        domGenKeyWarning: document.getElementById('genKeyWarning'),\n        domEncryptWarningTxt: document.getElementById('encryptWarningText'),\n        domEncryptBtnTxt: document.getElementById('encryptButton'),\n        domEncryptPasswordBox: document.getElementById('encryptPassword'),\n        domEncryptPasswordFirst: document.getElementById('newPassword'),\n        domEncryptPasswordSecond: document.getElementById('newPasswordRetype'),\n        domGuiAddress: document.getElementById('guiAddress'),\n        domGenIt: document.getElementById('genIt'),\n        domHumanReadable: document.getElementById('HumanReadable'),\n        domReqDesc: document.getElementById('reqDesc'),\n        domReqDisplay: document.getElementById('reqDescDisplay'),\n        domIdenticon: document.getElementById('identicon'),\n        domPrivKey: document.getElementById('privateKey'),\n        domPrivKeyPassword: document.getElementById('privateKeyPassword'),\n        domAvailToDelegate: document.getElementById('availToDelegate'),\n        domAvailToUndelegate: document.getElementById('availToUndelegate'),\n        domAnalyticsDescriptor: document.getElementById('analyticsDescriptor'),\n        domStakingRewardsList: document.getElementById(\n            'staking-rewards-content'\n        ),\n        domStakingRewardsTitle: document.getElementById(\n            'staking-rewards-title'\n        ),\n        domMnemonicModalContent: document.getElementById(\n            'ModalMnemonicContent'\n        ),\n        domMnemonicModalButton: document.getElementById(\n            'modalMnemonicConfirmButton'\n        ),\n        domMnemonicModalPassphrase: document.getElementById(\n            'ModalMnemonicPassphrase'\n        ),\n        domExportPrivateKey: document.getElementById('exportPrivateKeyText'),\n        domExportWallet: document.getElementById('guiExportWalletItem'),\n        domWipeWallet: document.getElementById('guiWipeWallet'),\n        domRestoreWallet: document.getElementById('guiRestoreWallet'),\n        domNewAddress: document.getElementById('guiNewAddress'),\n        domConfirmModalHeader: document.getElementById('confirmModalHeader'),\n        domConfirmModalTitle: document.getElementById('confirmModalTitle'),\n        domConfirmModalContent: document.getElementById('confirmModalContent'),\n        domConfirmModalButtons: document.getElementById('confirmModalButtons'),\n        domConfirmModalConfirmButton: document.getElementById(\n            'confirmModalConfirmButton'\n        ),\n        domConfirmModalCancelButton: document.getElementById(\n            'confirmModalCancelButton'\n        ),\n\n        masternodeLegacyAccessText:\n            'Access the masternode linked to this address<br> Note: the masternode MUST have been already created (however it can be online or offline)<br>  If you want to create a new masternode access with a HD wallet',\n        masternodeHDAccessText:\n            \"Access your masternodes if you have any! If you don't you can create one\",\n        // Aggregate menu screens and links for faster switching\n        arrDomScreens: document.getElementsByClassName('tabcontent'),\n        arrDomScreenLinks: document.getElementsByClassName('tablinks'),\n        // Alert DOM element\n        domAlertPos: document.getElementsByClassName('alertPositioning')[0],\n        domNetwork: document.getElementById('Network'),\n        domDebug: document.getElementById('Debug'),\n        domTestnet: document.getElementById('Testnet'),\n        domCurrencySelect: document.getElementById('currency'),\n        domExplorerSelect: document.getElementById('explorer'),\n        domNodeSelect: document.getElementById('node'),\n        domTranslationSelect: document.getElementById('translation'),\n        domBlackBack: document.getElementById('blackBack'),\n    };\n    i18nStart();\n    loadImages();\n\n    // Enable all Bootstrap Tooltips\n    $(function () {\n        $('[data-toggle=\"tooltip\"]').tooltip();\n    });\n\n    // Register Input Pair events\n    doms.domSendAmountCoins.oninput = () => {\n        updateAmountInputPair(\n            doms.domSendAmountCoins,\n            doms.domSendAmountValue,\n            true\n        );\n    };\n    doms.domSendAmountValue.oninput = () => {\n        updateAmountInputPair(\n            doms.domSendAmountCoins,\n            doms.domSendAmountValue,\n            false\n        );\n    };\n\n    // Register native app service\n    registerWorker();\n\n    // Configure Identicon\n    jdenticon.configure();\n\n    // URL-Query request processing\n    const urlParams = new URLSearchParams(window.location.search);\n\n    // Check for a payment request address\n    const reqTo = urlParams.has('pay') ? urlParams.get('pay') : '';\n\n    // Check for a payment request amount\n    const reqAmount = urlParams.has('amount')\n        ? parseFloat(urlParams.get('amount'))\n        : 0;\n\n    // Customise the UI if a saved wallet exists\n    if (hasEncryptedWallet()) {\n        // Hide the 'Generate wallet' buttons\n        doms.domGenerateWallet.style.display = 'none';\n        doms.domGenVanityWallet.style.display = 'none';\n\n        const publicKey = localStorage.getItem('publicKey');\n\n        if (publicKey) {\n            importWallet({ newWif: publicKey });\n        } else {\n            // Display the password unlock upfront\n            accessOrImportWallet();\n        }\n    }\n\n    // Payment processor redirect\n    if (reqTo.length || reqAmount > 0) {\n        guiPreparePayment(\n            reqTo,\n            reqAmount,\n            urlParams.has('desc') ? urlParams.get('desc') : ''\n        );\n    }\n\n    subscribeToNetworkEvents();\n\n    doms.domPrefix.value = '';\n    doms.domPrefixNetwork.innerText =\n        cChainParams.current.PUBKEY_PREFIX.join(' or ');\n    settingsStart();\n    // If allowed by settings: submit a simple 'hit' (app load) to Labs Analytics\n    getNetwork().submitAnalytics('hit');\n    setInterval(refreshChainData, 15000);\n}\n\nfunction subscribeToNetworkEvents() {\n    getEventEmitter().on('network-toggle', (value) => {\n        doms.domNetwork.innerHTML =\n            '<i class=\"fa-solid fa-' + (value ? 'wifi' : 'ban') + '\"></i>';\n    });\n\n    getEventEmitter().on('sync-status', (value) => {\n        switch (value) {\n            case 'start':\n                // Play reload anim\n                doms.domBalanceReload.classList.add('playAnim');\n                doms.domBalanceReloadStaking.classList.add('playAnim');\n                break;\n            case 'stop':\n                doms.domBalanceReload.classList.remove('playAnim');\n                doms.domBalanceReloadStaking.classList.remove('playAnim');\n                break;\n        }\n    });\n\n    getEventEmitter().on('transaction-sent', (success, result) => {\n        if (success) {\n            doms.domAddress1s.value = '';\n            doms.domSendAmountCoins.innerHTML = '';\n            createAlert(\n                'success',\n                `Transaction sent!<br>${result}`,\n                result ? 1250 + result.length * 50 : 3000\n            );\n            // If allowed by settings: submit a simple 'tx' ping to Labs Analytics\n            getNetwork().submitAnalytics('transaction');\n        } else {\n            createAlert('warning', 'Transaction Failed!', 1250);\n        }\n    });\n}\n\n// WALLET STATE DATA\nexport const mempool = new Mempool();\nlet exportHidden = false;\n\n//                        PIVX Labs' Cold Pool\nexport let cachedColdStakeAddr = 'SdgQDpS8jDRJDX8yK8m9KnTMarsE84zdsy';\n\nexport function openTab(evt, tabName) {\n    // Hide all screens and deactivate link highlights\n    for (const domScreen of doms.arrDomScreens)\n        domScreen.style.display = 'none';\n    for (const domLink of doms.arrDomScreenLinks)\n        domLink.classList.remove('active');\n\n    // Show and activate the given screen\n    document.getElementById(tabName).style.display = 'block';\n    evt.currentTarget.classList.add('active');\n\n    // Close the navbar if it's not already closed\n    if (!doms.domNavbarToggler.className.includes('collapsed'))\n        doms.domNavbarToggler.click();\n\n    if (tabName === 'Governance') {\n        updateGovernanceTab();\n    }\n    if (tabName === 'Masternode') {\n        updateMasternodeTab();\n    }\n}\n\nexport function getBalance(updateGUI = false) {\n    const nBalance = mempool.getBalance();\n    const nCoins = nBalance / COIN;\n\n    // Update the GUI too, if chosen\n    if (updateGUI) {\n        // Set the balance, and adjust font-size for large balance strings\n        const nLen = nCoins.toFixed(2).length;\n        doms.domGuiBalance.innerText = nCoins.toFixed(nLen >= 6 ? 0 : 2);\n        doms.domAvailToDelegate.innerText =\n            'Available: ~' +\n            nCoins.toFixed(2) +\n            ' ' +\n            cChainParams.current.TICKER;\n\n        // Update currency values\n        cMarket.getPrice(strCurrency).then((nPrice) => {\n            // Configure locale settings by detecting currency support\n            const cLocale = Intl.supportedValuesOf('currency').includes(\n                strCurrency.toUpperCase()\n            )\n                ? {\n                      style: 'currency',\n                      currency: strCurrency,\n                      currencyDisplay: 'narrowSymbol',\n                  }\n                : { maximumFractionDigits: 8, minimumFractionDigits: 8 };\n            let nValue = nCoins * nPrice;\n            // Handle certain edge-cases; like satoshis having decimals.\n            switch (strCurrency) {\n                case 'sats':\n                    nValue = Math.round(nValue);\n                    cLocale.maximumFractionDigits = 0;\n                    cLocale.minimumFractionDigits = 0;\n            }\n            doms.domGuiBalanceValue.innerText = nValue.toLocaleString(\n                'en-gb',\n                cLocale\n            );\n\n            // Update the Dashboard currency\n            doms.domGuiBalanceValueCurrency.innerText =\n                strCurrency.toUpperCase();\n\n            // Update the Send menu ticker and currency\n            doms.domSendAmountValueCurrency.innerText =\n                strCurrency.toUpperCase();\n            doms.domSendAmountCoinsTicker.innerText =\n                cChainParams.current.TICKER;\n        });\n    }\n\n    return nBalance;\n}\n\nexport function getStakingBalance(updateGUI = false) {\n    const nBalance = mempool.getDelegatedBalance();\n\n    if (updateGUI) {\n        // Set the balance, and adjust font-size for large balance strings\n        doms.domGuiBalanceStaking.innerText = Math.floor(nBalance / COIN);\n        doms.domGuiBalanceBoxStaking.style.fontSize =\n            Math.floor(nBalance / COIN).toString().length >= 4\n                ? 'large'\n                : 'x-large';\n        doms.domAvailToUndelegate.innerText =\n            'Staking: ~' +\n            (nBalance / COIN).toFixed(2) +\n            ' ' +\n            cChainParams.current.TICKER;\n    }\n\n    return nBalance;\n}\n\nexport function selectMaxBalance(domValueInput, fCold = false) {\n    domValueInput.value = (fCold ? getStakingBalance() : getBalance()) / COIN;\n    // Update the Send menu's value (assumption: if it's not a Cold balance, it's probably for Sending!)\n    if (!fCold)\n        updateAmountInputPair(\n            doms.domSendAmountCoins,\n            doms.domSendAmountValue,\n            true\n        );\n}\n\nexport async function openScanner() {\n    const cScan = await scanQRCode();\n    createAlert('warning', 'scaaanned -> ' + cScan.data);\n\n    if (!cScan || !cScan.data) return;\n    createAlert('warning', 'PASSDE DE CHEK');\n\n    /* Check what data the scan contains - for the various QR request types */\n\n    // Plain address (Length and Net Prefix matches)\n    if (cScan.data.length === 34) {\n        createAlert('warning', 'addr -> ' + cScan.data);\n        if (cChainParams.current.PUBKEY_ADDRESS.includes(cScan.data[0])) {\n            return guiPreparePayment(cScan.data);\n        } else {\n            // Length looks good, but strange Net Prefix...\n            return createAlert('warning', `Address starts with \"${cScan.data[0]}\", which is invalid for your wallet`, [], 7500);\n        }\n    }\n\n    // BIP21 Payment Request (Optional 'amount' and 'label')\n    const cBIP21Req = parseBIP21Request(cScan.data);\n    //alert(cBIP21Req);\n    //lalert(JSON.stringify(cBIP21Req, null, 4));\n    if (cBIP21Req) {\n        createAlert('warning', 'BIP21 -> ' + cScan.data);\n        return guiPreparePayment(cBIP21Req.address, cBIP21Req.amount ?? 0, cBIP21Req.label ?? '');\n    }\n\n    // No idea what this is...\n    createAlert('warning', `\"${cScan.data}\" is not a valid payment receiver`, [], 7500);\n}\n\nexport async function updateStakingRewardsGUI() {\n    const network = getNetwork();\n    const arrRewards = await network.getStakingRewards();\n    if (network.areRewardsComplete) {\n        // Hide the load more button\n        doms.domGuiStakingLoadMore.style.display = 'none';\n    }\n\n    //DOMS.DOM-optimised list generation\n    const strList = arrRewards\n        .map(\n            (cReward) =>\n                `<i style=\"opacity: 0.75; cursor: pointer\" onclick=\"window.open('${\n                    cExplorer.url + '/tx/' + cReward.id\n                }', '_blank')\">${new Date(\n                    cReward.time * 1000\n                ).toLocaleDateString()}</i> <b>+${cReward.amount} ${\n                    cChainParams.current.TICKER\n                }</b>`\n        )\n        .join('<br>');\n    // Calculate total\n    const nRewards = arrRewards.reduce(\n        (total, reward) => total + reward.amount,\n        0\n    );\n    // UpdateDOMS.DOM\n    doms.domStakingRewardsTitle.innerHTML = `Staking Rewards: ≥${nRewards} ${cChainParams.current.TICKER}`;\n    doms.domStakingRewardsList.innerHTML = strList;\n}\n\n/**\n * Open the Explorer in a new tab for the loaded master public key\n */\nexport async function openExplorer() {\n    if (masterKey.isHD) {\n        const derivationPath = getDerivationPath(masterKey.isHardwareWallet)\n            .split('/')\n            .slice(0, 4)\n            .join('/');\n        const xpub = await masterKey.getxpub(derivationPath);\n        window.open(cExplorer.url + '/xpub/' + xpub, '_blank');\n    } else {\n        const address = await masterKey.getAddress();\n        window.open(cExplorer.url + '/address/' + address, '_blank');\n    }\n}\n\nasync function loadImages() {\n    // Promise.all is useless since we only need to load one image, but we might need to load more in the future\n    Promise.all([\n        (async () => {\n            document.getElementById('mpw-main-logo').src = (\n                await import('../assets/logo.png')\n            ).default;\n            document.getElementById('privateKeyImage').src = (\n                await import('../assets/key.png')\n            ).default;\n        })(),\n    ]);\n}\n\nlet audio = null;\nexport async function playMusic() {\n    // On first play: load the audio into memory from the host\n    if (audio === null) {\n        // Dynamically load the file\n        audio = new Audio((await import('../assets/music.mp3')).default);\n    }\n\n    // Play or Pause\n    if (audio.paused || audio.ended) {\n        audio.play();\n        for (const domImg of document.getElementsByTagName('img'))\n            domImg.classList.add('discoFilter');\n    } else {\n        audio.pause();\n        for (const domImg of document.getElementsByTagName('img'))\n            domImg.classList.remove('discoFilter');\n    }\n}\n\nexport function unblurPrivKey() {\n    if (\n        document\n            .getElementById('exportPrivateKeyText')\n            .classList.contains('blurred')\n    ) {\n        document\n            .getElementById('exportPrivateKeyText')\n            .classList.remove('blurred');\n    } else {\n        document\n            .getElementById('exportPrivateKeyText')\n            .classList.add('blurred');\n    }\n}\n\nexport function toggleBottomMenu(dom, ani) {\n    let element = document.getElementById(dom);\n    if (element.classList.contains(ani)) {\n        element.classList.remove(ani);\n        doms.domBlackBack.classList.remove('d-none');\n        setTimeout(() => {\n            doms.domBlackBack.classList.remove('blackBackHide');\n        }, 10);\n    } else {\n        element.classList.add(ani);\n        doms.domBlackBack.classList.add('blackBackHide');\n        setTimeout(() => {\n            doms.domBlackBack.classList.add('d-none');\n        }, 150);\n    }\n}\n\n/**\n * Updates an Amount Input UI pair ('Coin' and 'Value' input boxes) in relation to the input box used\n * @param {HTMLInputElement} domCoin - The DOM input for the Coin amount\n * @param {HTMLInputElement} domValue - The DOM input for the Value amount\n * @param {boolean} fCoinEdited - `true` if Coin, `false` if Value\n */\nexport async function updateAmountInputPair(domCoin, domValue, fCoinEdited) {\n    // Fetch the price in the user's preferred currency\n    const nPrice = await cMarket.getPrice(strCurrency);\n    if (fCoinEdited) {\n        // If the 'Coin' input is edited, then update the 'Value' input with it's converted currency\n        const nValue = Number(doms.domSendAmountCoins.value) * nPrice;\n        domValue.value = nValue <= 0 ? '' : nValue;\n    } else {\n        // If the 'Value' input is edited, then update the 'Coin' input with the reversed conversion rate\n        const nValue = Number(doms.domSendAmountValue.value) / nPrice;\n        domCoin.value = nValue <= 0 ? '' : nValue;\n    }\n}\n\nexport function toClipboard(source, caller) {\n    // Fetch the text/value source\n    const domCopy = document.getElementById(source) || source;\n\n    // Use an invisible textbox as the clipboard source\n    const domClipboard = document.getElementById('clipboard');\n    domClipboard.value = domCopy.value || domCopy.innerHTML || domCopy;\n    domClipboard.select();\n    domClipboard.setSelectionRange(0, 99999);\n\n    // Browser-dependent clipboard execution\n    if (!navigator.clipboard) {\n        document.execCommand('copy');\n    } else {\n        navigator.clipboard.writeText(domCopy.innerHTML || domCopy);\n    }\n\n    // Display a temporary checkmark response\n    caller.classList.add('fa-check');\n    caller.classList.remove('fa-clipboard');\n    caller.style.cursor = 'default';\n    setTimeout(() => {\n        caller.classList.add('fa-clipboard');\n        caller.classList.remove('fa-check');\n        caller.style.cursor = 'pointer';\n    }, 1000);\n}\n\n/**\n * Prompt for a payment in the GUI with pre-filled inputs\n * @param {string} strTo - The address receiving the payment\n * @param {number} nAmount - The payment amount in full coins\n * @param {string} strDesc - The payment message or description\n */\nexport function guiPreparePayment(strTo = '', nAmount = 0, strDesc = '') {\n    // Apply values\n    doms.domAddress1s.value = strTo;\n    doms.domSendAmountCoins.value = nAmount;\n    doms.domReqDesc.value = strDesc;\n    doms.domReqDisplay.style.display = strDesc ? 'block' : 'none';\n\n    // Switch to the Dashboard\n    doms.domDashboard.click();\n\n    // Open the Send menu, if not already open (with a small timeout post-load to allow for CSS loading)\n    if (!document.getElementById('transferMenu').classList.includes('transferAnimation')) {\n        setTimeout(() => {\n            toggleBottomMenu('transferMenu', 'transferAnimation');\n        }, 300);\n    }\n\n    // Update the conversion value\n    updateAmountInputPair(\n        doms.domSendAmountCoins,\n        doms.domSendAmountValue,\n        true\n    );\n\n    // Focus on the coin input box\n    doms.domSendAmountCoins.focus();\n}\n\nexport function hideAllWalletOptions() {\n    // Hide and Reset the Vanity address input\n    doms.domPrefix.value = '';\n    doms.domPrefix.style.display = 'none';\n\n    // Hide all \"*Wallet\" buttons\n    doms.domGenerateWallet.style.display = 'none';\n    doms.domImportWallet.style.display = 'none';\n    doms.domGenVanityWallet.style.display = 'none';\n    doms.domAccessWallet.style.display = 'none';\n    doms.domGenHardwareWallet.style.display = 'none';\n}\n\nasync function govVote(hash, voteCode) {\n    if (\n        (await confirmPopup({\n            title: ALERTS.CONFIRM_POPUP_VOTE,\n            html: ALERTS.CONFIRM_POPUP_VOTE_HTML,\n        })) == true\n    ) {\n        if (localStorage.getItem('masternode')) {\n            const cMasternode = new Masternode(\n                JSON.parse(localStorage.getItem('masternode'))\n            );\n            if ((await cMasternode.getStatus()) !== 'ENABLED') {\n                createAlert(\n                    'warning',\n                    'Your masternode is not enabled yet!',\n                    6000\n                );\n                return;\n            }\n            const result = await cMasternode.vote(hash.toString(), voteCode); //1 yes 2 no\n            if (result.includes('Voted successfully')) {\n                //good vote\n                createAlert('success', 'Vote submitted!', 6000);\n            } else if (result.includes('Error voting :')) {\n                //If you already voted return an alert\n                createAlert(\n                    'warning',\n                    'You already voted for this proposal! Please wait 1 hour',\n                    6000\n                );\n            } else if (result.includes('Failure to verify signature.')) {\n                //wrong masternode private key\n                createAlert(\n                    'warning',\n                    \"Failed to verify signature, please check your masternode's private key\",\n                    6000\n                );\n            } else {\n                //this could be everything\n                console.error(result);\n                createAlert(\n                    'warning',\n                    'Internal error, please try again later',\n                    6000\n                );\n            }\n        } else {\n            createAlert('warning', 'Access a masternode before voting!', 6000);\n        }\n    }\n}\n\n/**\n * Start a Masternode via a signed network broadcast\n * @param {boolean} fRestart - Whether this is a Restart or a first Start\n */\nexport async function startMasternode(fRestart = false) {\n    if (localStorage.getItem('masternode')) {\n        if (\n            masterKey.isViewOnly &&\n            !(await restoreWallet('Unlock to start your Masternode!'))\n        )\n            return;\n        const cMasternode = new Masternode(\n            JSON.parse(localStorage.getItem('masternode'))\n        );\n        if (await cMasternode.start()) {\n            createAlert(\n                'success',\n                '<b>Masternode ' + (fRestart ? 're' : '') + 'started!</b>',\n                4000\n            );\n        } else {\n            createAlert(\n                'warning',\n                '<b>Failed to ' +\n                    (fRestart ? 're' : '') +\n                    'start masternode!</b>',\n                4000\n            );\n        }\n    }\n}\n\nexport function destroyMasternode() {\n    if (localStorage.getItem('masternode')) {\n        localStorage.removeItem('masternode');\n        createAlert(\n            'success',\n            '<b>Masternode destroyed!</b><br>Your coins are now spendable.',\n            5000\n        );\n        updateMasternodeTab();\n    }\n}\n\n/**\n * Takes an ip address and adds the port.\n * If it's an IPv4 address, ip:port will be used, (e.g. 127.0.0.1:12345)\n * If it's an IPv6 address, [ip]:port will be used, (e.g. [::1]:12345)\n * @param {String} ip - Ip address with or without port\n * @returns {String}\n */\nfunction parseIpAddress(ip) {\n    // IPv4 without port\n    if (ip.match(/\\d+\\.\\d+\\.\\d+\\.\\d+/)) {\n        return `${ip}:${cChainParams.current.MASTERNODE_PORT}`;\n    }\n    // IPv4 with port\n    if (ip.match(/\\d+\\.\\d+\\.\\d+\\.\\d+:\\d+/)) {\n        return ip;\n    }\n    // IPv6 without port\n    if (Address6.isValid(ip)) {\n        return `[${ip}]:${cChainParams.current.MASTERNODE_PORT}`;\n    }\n\n    const groups = /\\[(.*)\\]:\\d+/.exec(ip);\n    if (groups !== null && groups.length > 1) {\n        // IPv6 with port\n        if (Address6.isValid(groups[1])) {\n            return ip;\n        }\n    }\n\n    // If we haven't returned yet, the address was invalid.\n    return null;\n}\n\nexport async function importMasternode() {\n    const mnPrivKey = doms.domMnPrivateKey.value;\n    const address = parseIpAddress(doms.domMnIP.value);\n    if (!address) {\n        createAlert('warning', 'The ip address is invalid!', 5000);\n        return;\n    }\n\n    let collateralTxId;\n    let outidx;\n    let collateralPrivKeyPath;\n    doms.domMnIP.value = '';\n    doms.domMnPrivateKey.value = '';\n\n    if (!masterKey.isHD) {\n        // Find the first UTXO matching the expected collateral size\n        const cCollaUTXO = mempool\n            .getConfirmed()\n            .find(\n                (cUTXO) => cUTXO.sats === cChainParams.current.collateralInSats\n            );\n\n        // If there's no valid UTXO, exit with a contextual message\n        if (!cCollaUTXO) {\n            if (getBalance(false) < cChainParams.current.collateralInSats) {\n                // Not enough balance to create an MN UTXO\n                createAlert(\n                    'warning',\n                    'You need <b>' +\n                        (cChainParams.current.collateralInSats -\n                            getBalance(false)) /\n                            COIN +\n                        ' more ' +\n                        cChainParams.current.TICKER +\n                        '</b> to create a Masternode!',\n                    10000\n                );\n            } else {\n                // Balance is capable of a masternode, just needs to be created\n                // TODO: this UX flow is weird, is it even possible? perhaps we can re-design this entire function accordingly\n                createAlert(\n                    'warning',\n                    'You have enough balance for a Masternode, but no valid collateral UTXO of ' +\n                        cChainParams.current.collateralInSats / COIN +\n                        ' ' +\n                        cChainParams.current.TICKER,\n                    10000\n                );\n            }\n            return;\n        }\n\n        collateralTxId = cCollaUTXO.id;\n        outidx = cCollaUTXO.vout;\n        collateralPrivKeyPath = 'legacy';\n    } else {\n        const path = doms.domMnTxId.value;\n        const masterUtxo = mempool\n            .getConfirmed()\n            .findLast((u) => u.path === path); // first UTXO for each address in HD\n        // sanity check:\n        if (masterUtxo.sats !== cChainParams.current.collateralInSats) {\n            return createAlert(\n                'warning',\n                'This is not a suitable UTXO for a Masternode',\n                10000\n            );\n        }\n        collateralTxId = masterUtxo.id;\n        outidx = masterUtxo.vout;\n        collateralPrivKeyPath = path;\n    }\n    doms.domMnTxId.value = '';\n\n    const cMasternode = new Masternode({\n        walletPrivateKeyPath: collateralPrivKeyPath,\n        mnPrivateKey: mnPrivKey,\n        collateralTxId: collateralTxId,\n        outidx: outidx,\n        addr: address,\n    });\n    await refreshMasternodeData(cMasternode, true);\n    await updateMasternodeTab();\n}\n\nexport function accessOrImportWallet() {\n    // Hide and Reset the Vanity address input\n    doms.domPrefix.value = '';\n    doms.domPrefix.style.display = 'none';\n\n    // Show Import button, hide access button\n    doms.domImportWallet.style.display = 'block';\n    setTimeout(() => {\n        doms.domPrivKey.style.opacity = '1';\n    }, 100);\n    doms.domAccessWalletBtn.style.display = 'none';\n\n    // If we have a local wallet, display the decryption prompt\n    // This is no longer being used, as the user will be put in view-only\n    // mode when logging in, however if the user locked the wallet before\n    // #52 there would be no way to recover the public key without getting\n    // The password from the user\n    if (hasEncryptedWallet()) {\n        doms.domPrivKey.placeholder = 'Enter your wallet password';\n        doms.domImportWalletText.innerText = 'Unlock Wallet';\n        doms.domPrivKey.focus();\n    }\n}\n\nexport function onPrivateKeyChanged() {\n    if (hasEncryptedWallet()) return;\n    // Check whether the length of the string is 128 bytes (that's the length of ciphered plain texts)\n    // and it doesn't have any spaces (would be a mnemonic seed)\n    const fContainsSpaces = doms.domPrivKey.value.includes(' ');\n    doms.domPrivKeyPassword.hidden =\n        doms.domPrivKey.value.length !== 128 && !fContainsSpaces;\n\n    doms.domPrivKeyPassword.placeholder = fContainsSpaces\n        ? 'Optional Passphrase'\n        : 'Password';\n    // Uncloak the private input IF spaces are detected, to make Seed Phrases easier to input and verify\n    doms.domPrivKey.setAttribute('type', fContainsSpaces ? 'text' : 'password');\n}\n\nexport async function guiImportWallet() {\n    const fEncrypted = doms.domPrivKey.value.length === 128;\n\n    // If we are in testnet: prompt an import\n    if (cChainParams.current.isTestnet) return importWallet();\n\n    // If we don't have a DB wallet and the input is plain: prompt an import\n    if (!hasEncryptedWallet() && !fEncrypted) return importWallet();\n\n    // If we don't have a DB wallet and the input is ciphered:\n    const strPrivKey = doms.domPrivKey.value;\n    const strPassword = doms.domPrivKeyPassword.value;\n    if (!hasEncryptedWallet() && fEncrypted) {\n        const strDecWIF = await decrypt(strPrivKey, strPassword);\n        if (!strDecWIF || strDecWIF === 'decryption failed!') {\n            return createAlert('warning', ALERTS.FAILED_TO_IMPORT, [], 6000);\n        } else {\n            localStorage.setItem('encwif', strPrivKey);\n            return importWallet({\n                newWif: strDecWIF,\n            });\n        }\n    }\n    // Prompt for decryption of the existing wallet\n    const fHasWallet = await decryptWallet(doms.domPrivKey.value);\n\n    // If the wallet was successfully loaded, hide all options and load the dash!\n    if (fHasWallet) hideAllWalletOptions();\n}\n\nexport function guiEncryptWallet() {\n    // Disable wallet encryption in testnet mode\n    if (cChainParams.current.isTestnet)\n        return createAlert(\n            'warning',\n            ALERTS.TESTNET_ENCRYPTION_DISABLED,\n            [],\n            2500\n        );\n\n    // Fetch our inputs, ensure they're of decent entropy + match eachother\n    const strPass = doms.domEncryptPasswordFirst.value,\n        strPassRetype = doms.domEncryptPasswordSecond.value;\n    if (strPass.length < MIN_PASS_LENGTH)\n        return createAlert(\n            'warning',\n            ALERTS.PASSWORD_TOO_SMALL,\n            [{ MIN_PASS_LENGTH: MIN_PASS_LENGTH }],\n            4000\n        );\n    if (strPass !== strPassRetype)\n        return createAlert('warning', ALERTS.PASSWORD_DOESNT_MATCH, [], 2250);\n    encryptWallet(strPass);\n    createAlert('success', ALERTS.NEW_PASSWORD_SUCCESS, [], 5500);\n\n    $('#encryptWalletModal').modal('hide');\n\n    doms.domWipeWallet.hidden = false;\n}\n\nexport async function toggleExportUI() {\n    if (!exportHidden) {\n        if (hasEncryptedWallet()) {\n            doms.domExportPrivateKey.innerHTML = localStorage.getItem('encwif');\n            exportHidden = true;\n        } else {\n            if (masterKey.isViewOnly) {\n                exportHidden = false;\n            } else {\n                doms.domExportPrivateKey.innerHTML = masterKey.keyToBackup;\n                exportHidden = true;\n            }\n        }\n    } else {\n        doms.domExportPrivateKey.innerHTML = '';\n        exportHidden = false;\n    }\n}\n\nexport function checkVanity() {\n    var e = event || window.event; // get event object\n    var key = e.keyCode || e.which; // get key cross-browser\n    var char = String.fromCharCode(key).trim(); // convert key to char\n    if (char.length == 0) return;\n\n    // Ensure the input is base58 compatible\n    if (!MAP_B58.toLowerCase().includes(char.toLowerCase())) {\n        if (e.preventDefault) e.preventDefault();\n        e.returnValue = false;\n        return createAlert(\n            'warning',\n            ALERTS.UNSUPPORTED_CHARACTER,\n            [{ char: char }],\n            3500\n        );\n    }\n}\n\nlet isVanityGenerating = false;\nconst arrWorkers = [];\nlet vanUiUpdater;\n\nfunction stopSearch() {\n    isVanityGenerating = false;\n    for (let thread of arrWorkers) {\n        thread.terminate();\n    }\n    while (arrWorkers.length) arrWorkers.pop();\n    doms.domPrefix.disabled = false;\n    doms.domVanityUiButtonTxt.innerText = 'Create A Vanity Wallet';\n    clearInterval(vanUiUpdater);\n}\n\nexport async function generateVanityWallet() {\n    if (isVanityGenerating) return stopSearch();\n    if (typeof Worker === 'undefined')\n        return createAlert('error', ALERTS.UNSUPPORTED_WEBWORKERS, [], 7500);\n    // Generate a vanity address with the given prefix\n    if (\n        doms.domPrefix.value.length === 0 ||\n        doms.domPrefix.style.display === 'none'\n    ) {\n        // No prefix, display the intro!\n        doms.domPrefix.style.display = 'block';\n        setTimeout(() => {\n            doms.domPrefix.style.opacity = '1';\n        }, 100);\n        doms.domGuiAddress.innerHTML = '~';\n        doms.domPrefix.focus();\n    } else {\n        // Remove spaces from prefix\n        doms.domPrefix.value = doms.domPrefix.value.replace(/ /g, '');\n\n        // Cache a lowercase equivilent for lower-entropy comparisons (a case-insensitive search is ALOT faster!) and strip accidental spaces\n        const nInsensitivePrefix = doms.domPrefix.value.toLowerCase();\n        const nPrefixLen = nInsensitivePrefix.length;\n\n        // Ensure the input is base58 compatible\n        for (const char of doms.domPrefix.value) {\n            if (!MAP_B58.toLowerCase().includes(char.toLowerCase()))\n                return createAlert(\n                    'warning',\n                    ALERTS.UNSUPPORTED_CHARACTER,\n                    [{ char: char }],\n                    3500\n                );\n            // We also don't want users to be mining addresses for years... so cap the letters to four until the generator is more optimized\n            if (doms.domPrefix.value.length > 5)\n                return createAlert(\n                    'warning',\n                    ALERTS.UNSUPPORTED_CHARACTER,\n                    [{ char: char }],\n                    3500\n                );\n        }\n        isVanityGenerating = true;\n        doms.domPrefix.disabled = true;\n        let attempts = 0;\n\n        // Setup workers\n        const nThreads = Math.max(\n            Math.floor(window.navigator.hardwareConcurrency * 0.75),\n            1\n        );\n        console.log('Spawning ' + nThreads + ' vanity search threads!');\n        while (arrWorkers.length < nThreads) {\n            arrWorkers.push(\n                new Worker(new URL('./vanitygen_worker.js', import.meta.url))\n            );\n            const checkResult = (data) => {\n                attempts++;\n                if (\n                    data.pub.substr(1, nPrefixLen).toLowerCase() ==\n                    nInsensitivePrefix\n                ) {\n                    importWallet({\n                        newWif: data.priv,\n                        fRaw: true,\n                    });\n                    stopSearch();\n                    doms.domGuiBalance.innerHTML = '0';\n                    doms.domGuiBalanceBox.style.fontSize = 'x-large';\n                    return console.log(\n                        'VANITY: Found an address after ' +\n                            attempts +\n                            ' attempts!'\n                    );\n                }\n            };\n\n            arrWorkers[arrWorkers.length - 1].onmessage = (event) =>\n                checkResult(event.data);\n            arrWorkers[arrWorkers.length - 1].postMessage(\n                cChainParams.current.PUBKEY_ADDRESS\n            );\n        }\n\n        // GUI Updater\n        doms.domVanityUiButtonTxt.innerText =\n            'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';\n        vanUiUpdater = setInterval(() => {\n            doms.domVanityUiButtonTxt.innerText =\n                'Stop (Searched ' + attempts.toLocaleString('en-GB') + ' keys)';\n        }, 200);\n    }\n}\n\nexport function toggleDropDown(id) {\n    const domID = document.getElementById(id);\n    domID.style.display = domID.style.display === 'block' ? 'none' : 'block';\n}\n\nexport function askForCSAddr(force = false) {\n    if (force) cachedColdStakeAddr = null;\n    if (cachedColdStakeAddr === '' || cachedColdStakeAddr === null) {\n        cachedColdStakeAddr = prompt(\n            'Please provide a Cold Staking address (either from your own node, or a 3rd-party!)'\n        ).trim();\n        if (cachedColdStakeAddr) return true;\n    } else {\n        return true;\n    }\n    return false;\n}\n\nexport function isMasternodeUTXO(cUTXO, masternode = null) {\n    const cMasternode =\n        masternode || JSON.parse(localStorage.getItem('masternode'));\n    if (cMasternode) {\n        const { collateralTxId, outidx } = cMasternode;\n        return collateralTxId === cUTXO.id && cUTXO.vout === outidx;\n    } else {\n        return false;\n    }\n}\n\nexport async function wipePrivateData() {\n    const title = hasEncryptedWallet()\n        ? 'Do you want to lock your wallet?'\n        : 'Do you want to wipe your wallet private data?';\n    const html = hasEncryptedWallet()\n        ? 'You will need to enter your password to access your funds'\n        : \"You will lose access to your funds if you haven't backed up your private key or seed phrase\";\n    if (\n        await confirmPopup({\n            title,\n            html,\n        })\n    ) {\n        masterKey.wipePrivateData();\n        doms.domWipeWallet.hidden = true;\n        if (hasEncryptedWallet()) {\n            doms.domRestoreWallet.hidden = false;\n        }\n    }\n}\n\n/**\n * Prompt the user in the GUI to unlock their wallet\n * @param {string} strReason - An optional reason for the unlock\n * @returns {Promise<boolean>} - If the unlock was successful or rejected\n */\nexport async function restoreWallet(strReason = '') {\n    // Build up the UI elements based upon conditions for the unlock prompt\n    let strHTML = '';\n\n    // If there's a reason given; display it as a sub-text\n    strHTML += `<p style=\"opacity: 0.75\">${strReason}</p>`;\n\n    // Prompt the user\n    if (\n        await confirmPopup({\n            title: 'Unlock your wallet',\n            html: `${strHTML}<input type=\"password\" id=\"restoreWalletPassword\" placeholder=\"Wallet password\" style=\"text-align: center;\">`,\n        })\n    ) {\n        // Attempt to unlock the wallet with the provided password\n        const strPassword = document.getElementById(\n            'restoreWalletPassword'\n        ).value;\n        if (await decryptWallet(strPassword)) {\n            doms.domRestoreWallet.hidden = true;\n            doms.domWipeWallet.hidden = false;\n            // Wallet is unlocked!\n            return true;\n        } else {\n            // Password is invalid\n            return false;\n        }\n    } else {\n        // User rejected the unlock\n        return false;\n    }\n}\n\n/**\n * Fetch Governance data and re-render the Governance UI\n */\nasync function updateGovernanceTab() {\n    // Fetch all proposals from the network\n    const arrProposals = await Masternode.getProposals({\n        fAllowFinished: false,\n    });\n\n    /* Sort proposals into two categories\n        - Standard (Proposal is either new with <100 votes, or has a healthy vote count)\n        - Contested (When a proposal may be considered spam, malicious, or simply highly contestable)\n    */\n    const arrStandard = arrProposals.filter(\n        (a) => a.Yeas + a.Nays < 100 || a.Ratio > 0.25\n    );\n    const arrContested = arrProposals.filter(\n        (a) => a.Yeas + a.Nays >= 100 && a.Ratio <= 0.25\n    );\n\n    // Render Proposals\n    renderProposals(arrStandard, false);\n    renderProposals(arrContested, true);\n}\n\n/**\n * Render Governance proposal objects to a given Proposal category\n * @param {Array<object>} arrProposals - The proposals to render\n * @param {boolean} fContested - The proposal category\n */\nfunction renderProposals(arrProposals, fContested) {\n    // Select the table based on the proposal category\n    const domTable = fContested\n        ? doms.domGovProposalsContestedTableBody\n        : doms.domGovProposalsTableBody;\n\n    // Render the proposals in the relevent table\n    domTable.innerHTML = '';\n    for (const cProposal of arrProposals) {\n        const domRow = domTable.insertRow();\n\n        // Name and URL hyperlink\n        const domNameAndURL = domRow.insertCell();\n        // IMPORTANT: Sanitise all of our HTML or a rogue server or malicious proposal could perform a cross-site scripting attack\n        domNameAndURL.innerHTML = `<a class=\"active\" href=\"${sanitizeHTML(\n            cProposal.URL\n        )}\" target=\"_blank\" rel=\"noopener noreferrer\"><b>${sanitizeHTML(cProposal.Name)}</b></a>`;\n\n        // Payment Schedule and Amounts\n        const domPayments = domRow.insertCell();\n        domPayments.innerHTML = `<b>${sanitizeHTML(\n            cProposal.MonthlyPayment\n        )}</b> ${cChainParams.current.TICKER} <br>\n      <small> ${sanitizeHTML(\n          cProposal['RemainingPaymentCount']\n      )} payments remaining of <b>${sanitizeHTML(cProposal.TotalPayment)}</b> ${\n            cChainParams.current.TICKER\n        } total</small>`;\n\n        // Vote Counts and Consensus Percentages\n        const domVoteCounters = domRow.insertCell();\n        const { Yeas, Nays } = cProposal;\n        const nPercent = cProposal.Ratio * 100;\n\n        domVoteCounters.innerHTML = `<b>${nPercent.toFixed(2)}%</b> <br>\n      <small> <b><div class=\"text-success\" style=\"display:inline;\"> ${Yeas} </div></b> /\n\t  <b><div class=\"text-danger\" style=\"display:inline;\"> ${Nays} </div></b>\n      `;\n\n        // Voting Buttons for Masternode owners (MNOs)\n        const domVoteBtns = domRow.insertCell();\n        const domNoBtn = document.createElement('button');\n        domNoBtn.className = 'pivx-button-big';\n        domNoBtn.innerText = 'No';\n        domNoBtn.onclick = () => govVote(cProposal.Hash, 2);\n\n        const domYesBtn = document.createElement('button');\n        domYesBtn.className = 'pivx-button-big';\n        domYesBtn.innerText = 'Yes';\n        domYesBtn.onclick = () => govVote(cProposal.Hash, 1);\n\n        domVoteBtns.appendChild(domNoBtn);\n        domVoteBtns.appendChild(domYesBtn);\n    }\n}\n\nexport async function updateMasternodeTab() {\n    //TODO: IN A FUTURE ADD MULTI-MASTERNODE SUPPORT BY SAVING MNs with which you logged in the past.\n    // Ensure a wallet is loaded\n    doms.domMnTextErrors.innerHTML = '';\n    doms.domAccessMasternode.style.display = 'none';\n    doms.domCreateMasternode.style.display = 'none';\n    doms.domMnDashboard.style.display = 'none';\n\n    if (!masterKey) {\n        doms.domMnTextErrors.innerHTML =\n            'Please ' +\n            (hasEncryptedWallet() ? 'unlock' : 'import') +\n            ' your <b>COLLATERAL WALLET</b> first.';\n        return;\n    }\n\n    if (masterKey.isHardwareWallet) {\n        doms.domMnTxId.style.display = 'none';\n        doms.domMnTextErrors.innerHTML = 'Ledger is not yet supported';\n        return;\n    }\n\n    if (!mempool.getConfirmed().length) {\n        doms.domMnTextErrors.innerHTML =\n            'Your wallet is empty or still loading, re-open the tab in a few seconds!';\n        return;\n    }\n\n    let strMasternodeJSON = localStorage.getItem('masternode');\n    // If the collateral is missing (spent, or switched wallet) then remove the current MN\n    if (strMasternodeJSON) {\n        const cMasternode = JSON.parse(strMasternodeJSON);\n        if (\n            !mempool\n                .getConfirmed()\n                .find((utxo) => isMasternodeUTXO(utxo, cMasternode))\n        ) {\n            localStorage.removeItem('masternode');\n            strMasternodeJSON = null;\n        }\n    }\n\n    doms.domControlMasternode.style.display = strMasternodeJSON\n        ? 'block'\n        : 'none';\n\n    // first case: the wallet is not HD and it is not hardware, so in case the wallet has collateral the user can check its status and do simple stuff like voting\n    if (!masterKey.isHD) {\n        doms.domMnAccessMasternodeText.innerHTML =\n            doms.masternodeLegacyAccessText;\n        doms.domMnTxId.style.display = 'none';\n        // Find the first UTXO matching the expected collateral size\n        const cCollaUTXO = mempool\n            .getConfirmed()\n            .find(\n                (cUTXO) => cUTXO.sats === cChainParams.current.collateralInSats\n            );\n        const balance = getBalance(false);\n        if (cCollaUTXO) {\n            if (strMasternodeJSON) {\n                const cMasternode = new Masternode(\n                    JSON.parse(localStorage.getItem('masternode'))\n                );\n                await refreshMasternodeData(cMasternode);\n                doms.domMnDashboard.style.display = '';\n            } else {\n                doms.domMnTxId.style.display = 'none';\n                doms.domccessMasternode.style.display = 'block';\n            }\n        } else if (balance < cChainParams.current.collateralInSats) {\n            // The user needs more funds\n            doms.domMnTextErrors.innerHTML =\n                'You need <b>' +\n                (cChainParams.current.collateralInSats - balance) / COIN +\n                ' more ' +\n                cChainParams.current.TICKER +\n                '</b> to create a Masternode!';\n        } else {\n            // The user has the funds, but not an exact collateral, prompt for them to create one\n            doms.domCreateMasternode.style.display = 'block';\n            doms.domMnTxId.style.display = 'none';\n            doms.domMnTxId.innerHTML = '';\n        }\n    } else {\n        doms.domMnTxId.style.display = 'none';\n        doms.domMnTxId.innerHTML = '';\n        doms.domMnAccessMasternodeText.innerHTML = doms.masternodeHDAccessText;\n\n        // First UTXO for each address in HD\n        const mapCollateralAddresses = new Map();\n\n        // Aggregate all valid Masternode collaterals into a map of Address <--> Collateral\n        for (const cUTXO of mempool.getConfirmed()) {\n            if (cUTXO.sats !== cChainParams.current.collateralInSats) continue;\n            mapCollateralAddresses.set(cUTXO.path, cUTXO);\n        }\n        const fHasCollateral = mapCollateralAddresses.size > 0;\n\n        // If there's no loaded MN, but valid collaterals, display the configuration screen\n        if (!strMasternodeJSON && fHasCollateral) {\n            doms.domMnTxId.style.display = 'block';\n            doms.domAccessMasternode.style.display = 'block';\n\n            for (const [key] of mapCollateralAddresses) {\n                const option = document.createElement('option');\n                option.value = key;\n                option.innerText = await masterKey.getAddress(key);\n                doms.domMnTxId.appendChild(option);\n            }\n        }\n\n        // If there's no collateral found, display the creation UI\n        if (!fHasCollateral) doms.domCreateMasternode.style.display = 'block';\n\n        // If we have a collateral and a loaded Masternode, display the Dashboard\n        if (fHasCollateral && strMasternodeJSON) {\n            const cMasternode = new Masternode(JSON.parse(strMasternodeJSON));\n            // Refresh the display\n            refreshMasternodeData(cMasternode);\n            doms.domMnDashboard.style.display = '';\n        }\n    }\n}\n\nasync function refreshMasternodeData(cMasternode, fAlert = false) {\n    const cMasternodeData = await cMasternode.getFullData();\n    if (debug) console.log(cMasternodeData);\n\n    // If we have MN data available, update the dashboard\n    if (cMasternodeData && cMasternodeData.status !== 'MISSING') {\n        doms.domMnTextErrors.innerHTML = '';\n        doms.domMnProtocol.innerText = `(${sanitizeHTML(\n            cMasternodeData.version\n        )})`;\n        doms.domMnStatus.innerText = sanitizeHTML(cMasternodeData.status);\n        doms.domMnNetType.innerText = sanitizeHTML(\n            cMasternodeData.network.toUpperCase()\n        );\n        doms.domMnNetIP.innerText = cMasternode.addr;\n        doms.domMnLastSeen.innerText = new Date(\n            cMasternodeData.lastseen * 1000\n        ).toLocaleTimeString();\n    }\n\n    if (cMasternodeData.status === 'MISSING') {\n        doms.domMnTextErrors.innerHTML =\n            'Masternode is currently <b>OFFLINE</b>';\n        if (!masterKey.isViewOnly) {\n            createAlert(\n                'warning',\n                'Your masternode is offline, we will try to start it',\n                6000\n            );\n            // try to start the masternode\n            const started = await cMasternode.start();\n            if (started) {\n                doms.domMnTextErrors.innerHTML =\n                    'Masternode successfully started!';\n                createAlert(\n                    'success',\n                    'Masternode successfully started!, it will be soon online',\n                    6000\n                );\n                localStorage.setItem('masternode', JSON.stringify(cMasternode));\n            } else {\n                doms.domMnTextErrors.innerHTML =\n                    \"We couldn't start your masternode\";\n                createAlert(\n                    'warning',\n                    'We could not start your masternode',\n                    6000\n                );\n            }\n        }\n    } else if (\n        cMasternodeData.status === 'ENABLED' ||\n        cMasternodeData.status === 'PRE_ENABLED'\n    ) {\n        if (fAlert)\n            createAlert(\n                'success',\n                `Your masternode status is <b> ${sanitizeHTML(\n                    cMasternodeData.status\n                )} </b>`,\n                6000\n            );\n        localStorage.setItem('masternode', JSON.stringify(cMasternode));\n    } else if (cMasternodeData.status === 'REMOVED') {\n        doms.domMnTextErrors.innerHTML =\n            'Masternode is currently <b>REMOVED</b>';\n        if (fAlert)\n            createAlert(\n                'warning',\n                'Your masternode is in <b>REMOVED</b> state',\n                6000\n            );\n    } else {\n        // connection problem\n        doms.domMnTextErrors.innerHTML = 'Unable to connect!';\n        if (fAlert) createAlert('warning', 'Unable to connect!', 6000);\n    }\n\n    // Return the data in case the caller needs additional context\n    return cMasternodeData;\n}\n\nexport function refreshChainData() {\n    // If in offline mode: don't sync ANY data or connect to the internet\n    if (!getNetwork().enabled)\n        return console.warn(\n            'Offline mode active: For your security, the wallet will avoid ALL internet requests.'\n        );\n    if (!masterKey) return;\n\n    // Fetch block count + UTXOs\n    getNetwork().getBlockCount();\n    getBalance(true);\n\n    // Fetch pricing data\n    refreshPriceDisplay();\n}\n\n// A safety mechanism enabled if the user attempts to leave without encrypting/saving their keys\nexport const beforeUnloadListener = (evt) => {\n    evt.preventDefault();\n    // Disable Save your wallet warning on unload\n    if (!cChainParams.current.isTestnet)\n        createAlert('warning', ALERTS.SAVE_WALLET_PLEASE, [], 10000);\n    // Most browsers ignore this nowadays, but still, keep it 'just incase'\n    return (evt.returnValue = translation.BACKUP_OR_ENCRYPT_WALLET);\n};\n","import { getDerivationPath } from './wallet.js';\nimport { cChainParams, COIN } from './chain_params.js';\nimport { createAlert } from './misc.js';\nimport { Mempool, UTXO } from './mempool.js';\nimport { getEventEmitter } from './event_bus.js';\nimport { STATS, cStatKeys, cAnalyticsLevel } from './settings.js';\n\n/**\n * Virtual class rapresenting any network backend\n */\nexport class Network {\n    constructor(masterKey) {\n        if (this.constructor === Network) {\n            throw new Error('Initializing virtual class');\n        }\n        this._enabled = true;\n\n        this.masterKey = masterKey;\n\n        this.lastWallet = 0;\n        this.areRewardsComplete = false;\n    }\n\n    /**\n     * @param {boolean} value\n     */\n    set enabled(value) {\n        if (value !== this._enabled) {\n            getEventEmitter().emit('network-toggle', value);\n            this._enabled = value;\n        }\n    }\n\n    get enabled() {\n        return this._enabled;\n    }\n\n    enable() {\n        this.enabled = true;\n    }\n\n    disable() {\n        this.enabled = false;\n    }\n\n    toggle() {\n        this.enabled = !this.enabled;\n    }\n\n    getFee(bytes) {\n        // TEMPORARY: Hardcoded fee per-byte\n        return bytes * 50; // 50 sat/byte\n    }\n\n    get cachedBlockCount() {\n        throw new Error('cachedBlockCount must be implemented');\n    }\n\n    error() {\n        throw new Error('Error must be implemented');\n    }\n\n    getBlockCount() {\n        throw new Error('getBlockCount must be implemented');\n    }\n\n    sentTransaction() {\n        throw new Error('sendTransaction must be implemented');\n    }\n\n    submitAnalytics(strType, cData = {}) {\n        throw new Error('submitAnalytics must be implemented');\n    }\n\n    setMasterKey(masterKey) {\n        this.masterKey = masterKey;\n    }\n\n    async getTxInfo(txHash) {\n        throw new Error('getTxInfo must be implemented');\n    }\n}\n\n/**\n *\n */\nexport class ExplorerNetwork extends Network {\n    /**\n     * @param {string} strUrl - Url pointing to the blockbook explorer\n     */\n    constructor(strUrl, masterKey) {\n        super(masterKey);\n        /**\n         * @type{string}\n         * @public\n         */\n        this.strUrl = strUrl;\n\n        /**\n         * @type{Number}\n         * @private\n         */\n        this.blocks = 0;\n\n        this.arrRewards = [];\n        this.rewardsSyncing = false;\n    }\n\n    error() {\n        if (this.enabled) {\n            this.disable();\n            createAlert(\n                'warning',\n                '<b>Failed to synchronize!</b> Please try again later.' +\n                    '<br>You can attempt re-connect via the Settings.',\n                []\n            );\n        }\n    }\n\n    get cachedBlockCount() {\n        return this.blocks;\n    }\n\n    async getBlockCount() {\n        try {\n            getEventEmitter().emit('sync-status', 'start');\n            const { backend } = await (\n                await fetch(`${this.strUrl}/api/v2/api`)\n            ).json();\n            if (backend.blocks > this.blocks) {\n                console.log(\n                    'New block detected! ' +\n                        this.blocks +\n                        ' --> ' +\n                        backend.blocks\n                );\n                this.blocks = backend.blocks;\n\n                await this.getUTXOs();\n            }\n        } catch (e) {\n            this.error();\n            throw e;\n        } finally {\n            getEventEmitter().emit('sync-status', 'stop');\n        }\n    }\n\n    /**\n     * Fetch UTXOs from the current primary explorer\n     * @returns {Promise<void>} Resolves when it has finished fetching UTXOs\n     */\n    async getUTXOs() {\n        // Don't fetch UTXOs if we're already scanning for them!\n        if (!this.masterKey) return;\n        if (this.isSyncing) return;\n        this.isSyncing = true;\n        try {\n            let publicKey;\n            if (this.masterKey.isHD) {\n                const derivationPath = getDerivationPath(\n                    this.masterKey.isHardwareWallet\n                )\n                    .split('/')\n                    .slice(0, 4)\n                    .join('/');\n                publicKey = await this.masterKey.getxpub(derivationPath);\n            } else {\n                publicKey = await this.masterKey.getAddress();\n            }\n\n            getEventEmitter().emit(\n                'utxo',\n                await (\n                    await fetch(`${this.strUrl}/api/v2/utxo/${publicKey}`)\n                ).json()\n            );\n        } catch (e) {\n            console.error(e);\n            this.error();\n        } finally {\n            this.isSyncing = false;\n        }\n    }\n    /**\n     * Fetches UTXOs full info\n     * @param {Object} cUTXO - object-formatted UTXO\n     * @returns {Promise<UTXO>} Promise that resolves with the full info of the UTXO\n     */\n    async getUTXOFullInfo(cUTXO) {\n        const cTx = await (\n            await fetch(`${this.strUrl}/api/v2/tx-specific/${cUTXO.txid}`)\n        ).json();\n        const cVout = cTx.vout[cUTXO.vout];\n\n        let path;\n        if (cUTXO.path) {\n            path = cUTXO.path.split('/');\n            path[2] =\n                (this.masterKey.isHardwareWallet\n                    ? cChainParams.current.BIP44_TYPE_LEDGER\n                    : cChainParams.current.BIP44_TYPE) + \"'\";\n            this.lastWallet = Math.max(parseInt(path[5]), this.lastWallet);\n            path = path.join('/');\n        }\n\n        const isColdStake = cVout.scriptPubKey.type === 'coldstake';\n        const isStandard = cVout.scriptPubKey.type === 'pubkeyhash';\n        const isReward = cTx.vout[0].scriptPubKey.hex === '';\n        // We don't know what this is\n        if (!isColdStake && !isStandard) {\n            return null;\n        }\n\n        return new UTXO({\n            id: cUTXO.txid,\n            path,\n            sats: Math.round(cVout.value * COIN),\n            script: cVout.scriptPubKey.hex,\n            vout: cVout.n,\n            height: this.cachedBlockCount - (cTx.confirmations - 1),\n            status: cTx.confirmations < 1 ? Mempool.PENDING : Mempool.CONFIRMED,\n            isDelegate: isColdStake,\n            isReward,\n        });\n    }\n\n    async sendTransaction(hex) {\n        try {\n            const data = await (\n                await fetch(this.strUrl + '/api/v2/sendtx/', {\n                    method: 'post',\n                    body: hex,\n                })\n            ).json();\n            if (data.result && data.result.length === 64) {\n                console.log('Transaction sent! ' + data.result);\n                getEventEmitter().emit('transaction-sent', true, data.result);\n                return true;\n            } else {\n                console.log('Error sending transaction: ' + data.result);\n                getEventEmitter().emit('transaction-sent', false, data.error);\n                return false;\n            }\n        } catch (e) {\n            console.error(e);\n            this.error();\n        }\n    }\n\n    async getStakingRewards() {\n        if (this.rewardsSyncing) {\n            return this.arrRewards;\n        }\n        try {\n            if (!this.enabled || !this.masterKey || this.areRewardsComplete)\n                return this.arrRewards;\n            this.rewardsSyncing = true;\n            const nHeight = this.arrRewards.length\n                ? this.arrRewards[this.arrRewards.length - 1].blockHeight\n                : 0;\n            const mapPaths = new Map();\n            const txSum = (v) =>\n                v.reduce(\n                    (t, s) =>\n                        t +\n                        (s.addresses\n                            .map((strAddr) => mapPaths.get(strAddr))\n                            .filter((v) => v).length && s.addresses.length === 2\n                            ? parseInt(s.value)\n                            : 0),\n                    0\n                );\n            let cData;\n            if (this.masterKey.isHD) {\n                const derivationPath = getDerivationPath(\n                    this.masterKey.isHardwareWallet\n                )\n                    .split('/')\n                    .slice(0, 4)\n                    .join('/');\n                const xpub = await this.masterKey.getxpub(derivationPath);\n                cData = await (\n                    await fetch(\n                        `${\n                            this.strUrl\n                        }/api/v2/xpub/${xpub}?details=txs&pageSize=500&to=${\n                            nHeight ? nHeight - 1 : 0\n                        }`\n                    )\n                ).json();\n                // Map all address <--> derivation paths\n                if (cData.tokens)\n                    cData.tokens.forEach((cAddrPath) =>\n                        mapPaths.set(cAddrPath.name, cAddrPath.path)\n                    );\n            } else {\n                const address = await this.masterKey.getAddress();\n                cData = await (\n                    await fetch(\n                        `${\n                            this.strUrl\n                        }/api/v2/address/${address}?details=txs&pageSize=500&to=${\n                            nHeight ? nHeight - 1 : 0\n                        }`\n                    )\n                ).json();\n                mapPaths.set(address, ':)');\n            }\n            if (cData && cData.transactions) {\n                // Update rewards\n                this.arrRewards = this.arrRewards.concat(\n                    cData.transactions\n                        .filter(\n                            (tx) => tx.vout[0].addresses[0] === 'CoinStake TX'\n                        )\n                        .map((tx) => {\n                            return {\n                                id: tx.txid,\n                                time: tx.blockTime,\n                                blockHeight: tx.blockHeight,\n                                amount: (txSum(tx.vout) - txSum(tx.vin)) / COIN,\n                            };\n                        })\n                        .filter((tx) => tx.amount != 0)\n                );\n\n                // If the results don't match the full 'max/requested results', then we know the rewards are complete\n                if (cData.transactions.length !== cData.itemsOnPage) {\n                    this.areRewardsComplete = true;\n                }\n            }\n            return this.arrRewards;\n        } catch (e) {\n            console.error(e);\n        } finally {\n            this.rewardsSyncing = false;\n        }\n    }\n\n    setMasterKey(masterKey) {\n        this.masterKey = masterKey;\n        this.arrRewards = [];\n    }\n\n    async getTxInfo(txHash) {\n        const req = await fetch(`${this.strUrl}/api/v2/tx/${txHash}`);\n        return await req.json();\n    }\n\n    // PIVX Labs Analytics: if you are a user, you can disable this FULLY via the Settings.\n    // ... if you're a developer, we ask you to keep these stats to enhance upstream development,\n    // ... but you are free to completely strip MPW of any analytics, if you wish, no hard feelings.\n    submitAnalytics(strType, cData = {}) {\n        if (!this.enabled) return;\n\n        // Limit analytics here to prevent 'leakage' even if stats are implemented incorrectly or forced\n        let i = 0,\n            arrAllowedKeys = [];\n        for (i; i < cAnalyticsLevel.stats.length; i++) {\n            const cStat = cAnalyticsLevel.stats[i];\n            arrAllowedKeys.push(cStatKeys.find((a) => STATS[a] === cStat));\n        }\n\n        // Check if this 'stat type' was granted permissions\n        if (!arrAllowedKeys.includes(strType)) return false;\n\n        // Format\n        const cStats = { type: strType, ...cData };\n\n        // Send to Labs Analytics\n        const request = new XMLHttpRequest();\n        request.open('POST', 'https://scpscan.net/mpw/statistic', true);\n        request.setRequestHeader('Content-Type', 'application/json');\n        request.send(JSON.stringify(cStats));\n        return true;\n    }\n}\n\nlet _network = null;\n\n/**\n * Sets the network in use by MPW.\n * @param {Network} network - network to use\n */\nexport function setNetwork(network) {\n    _network = network;\n}\n\n/**\n * Sets the network in use by MPW.\n * @returns {Network?} Returns the network in use, may be null if MPW hasn't properly loaded yet.\n */\nexport function getNetwork() {\n    return _network;\n}\n","const buff_to_base64 = (buff) => btoa(String.fromCharCode.apply(null, buff));\n\nconst base64_to_buf = (b64) =>\n    Uint8Array.from(atob(b64), (c) => c.charCodeAt(null));\n\nconst enc = new TextEncoder();\nconst dec = new TextDecoder();\n\nexport async function encrypt(data, strPassword = '') {\n    const strPass =\n        strPassword ||\n        window.prompt('Please enter your wallet encryption password');\n    if (!strPass) return false;\n    return await encryptData(data, strPass);\n}\n\nexport async function decrypt(data, strPassword) {\n    const strPass =\n        strPassword ||\n        window.prompt('Please enter your wallet unlock password');\n    if (!strPass) return false;\n    return (await decryptData(data, strPass)) || 'decryption failed!';\n}\n\nconst getPasswordKey = (password) =>\n    window.crypto.subtle.importKey(\n        'raw',\n        enc.encode(password),\n        'PBKDF2',\n        false,\n        ['deriveKey']\n    );\n\nconst deriveKey = (passwordKey, salt, keyUsage) =>\n    window.crypto.subtle.deriveKey(\n        {\n            name: 'PBKDF2',\n            salt,\n            iterations: 250000,\n            hash: 'SHA-256',\n        },\n        passwordKey,\n        { name: 'AES-GCM', length: 256 },\n        false,\n        keyUsage\n    );\n\nasync function encryptData(secretData, password) {\n    try {\n        const salt = window.crypto.getRandomValues(new Uint8Array(16));\n        const iv = window.crypto.getRandomValues(new Uint8Array(12));\n        const passwordKey = await getPasswordKey(password);\n        const aesKey = await deriveKey(passwordKey, salt, ['encrypt']);\n        const encryptedContent = await window.crypto.subtle.encrypt(\n            {\n                name: 'AES-GCM',\n                iv: iv,\n            },\n            aesKey,\n            enc.encode(secretData)\n        );\n\n        const encryptedContentArr = new Uint8Array(encryptedContent);\n        let buff = new Uint8Array(\n            salt.byteLength + iv.byteLength + encryptedContentArr.byteLength\n        );\n        buff.set(salt, 0);\n        buff.set(iv, salt.byteLength);\n        buff.set(encryptedContentArr, salt.byteLength + iv.byteLength);\n        return buff_to_base64(buff);\n    } catch (e) {\n        console.log(`Error - ${e}`);\n        return '';\n    }\n}\n\nasync function decryptData(encryptedData, password) {\n    try {\n        const encryptedDataBuff = base64_to_buf(encryptedData);\n        const salt = encryptedDataBuff.slice(0, 16);\n        const iv = encryptedDataBuff.slice(16, 16 + 12);\n        const data = encryptedDataBuff.slice(16 + 12);\n        const passwordKey = await getPasswordKey(password);\n        const aesKey = await deriveKey(passwordKey, salt, ['decrypt']);\n        const decryptedContent = await window.crypto.subtle.decrypt(\n            {\n                name: 'AES-GCM',\n                iv: iv,\n            },\n            aesKey,\n            data\n        );\n        return dec.decode(decryptedContent);\n    } catch (e) {\n        console.log(`Error - ${e}`);\n        return '';\n    }\n}\n","import { hexToBytes, bytesToHex, dSHA256 } from './utils.js';\nimport * as nobleSecp256k1 from '@noble/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { generateMnemonic, mnemonicToSeed, validateMnemonic } from 'bip39';\nimport { doms, beforeUnloadListener } from './global.js';\nimport HDKey from 'hdkey';\nimport { getNetwork } from './network.js';\nimport {\n    pubKeyHashNetworkLen,\n    confirmPopup,\n    writeToUint8,\n    pubPrebaseLen,\n    createQR,\n    createAlert,\n    sleep,\n    getSafeRand,\n} from './misc.js';\nimport {\n    refreshChainData,\n    hideAllWalletOptions,\n    getBalance,\n    getStakingBalance,\n} from './global.js';\nimport {\n    cChainParams,\n    MAX_ACCOUNT_GAP,\n    PRIVKEY_BYTE_LENGTH,\n} from './chain_params.js';\nimport { ALERTS } from './i18n.js';\nimport { encrypt, decrypt } from './aes-gcm.js';\nimport bs58 from 'bs58';\nimport AppBtc from '@ledgerhq/hw-app-btc';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport createXpub from 'create-xpub';\nimport * as jdenticon from 'jdenticon';\n\nexport let fWalletLoaded = false;\n\n/**\n * Abstract class masterkey\n * @abstract\n */\nclass MasterKey {\n    /**\n     * @param {String} [path] - BIP32 path pointing to the private key.\n     * @return {Promise<Array<Number>>} Array of bytes containing private key\n     * @abstract\n     */\n    async getPrivateKeyBytes(_path) {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @param {String} [path] - BIP32 path pointing to the private key.\n     * @return {String} encoded private key\n     * @abstract\n     */\n    async getPrivateKey(path) {\n        return generateOrEncodePrivkey(await this.getPrivateKeyBytes(path))\n            .strWIF;\n    }\n\n    /**\n     * @param {String} [path] - BIP32 path pointing to the address\n     * @return {String} Address\n     * @abstract\n     */\n    async getAddress(path) {\n        return deriveAddress({ pkBytes: await this.getPrivateKeyBytes(path) });\n    }\n\n    /**\n     * @param {String} path - BIP32 path pointing to the xpub\n     * @return {Promise<String>} xpub\n     * @abstract\n     */\n    async getxpub(_path) {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * Wipe all private data from key.\n     * @return {void}\n     * @abstract\n     */\n    wipePrivateData() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @return {String} private key suitable for backup.\n     * @abstract\n     */\n    get keyToBackup() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @return {String} public key to export. Only suitable for monitoring balance.\n     * @abstract\n     */\n    get keyToExport() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @return {Boolean} Whether or not this is a Hierarchical Deterministic wallet\n     */\n    get isHD() {\n        return this._isHD;\n    }\n\n    /**\n     * @return {Boolean} Whether or not this is a hardware wallet\n     */\n    get isHardwareWallet() {\n        return this._isHardwareWallet;\n    }\n\n    /**\n     * @return {Boolean} Whether or not this key is view only or not\n     */\n    get isViewOnly() {\n        return this._isViewOnly;\n    }\n}\n\nexport class HdMasterKey extends MasterKey {\n    constructor({ seed, xpriv, xpub }) {\n        super();\n        // Generate the HDKey\n        if (seed) this._hdKey = HDKey.fromMasterSeed(seed);\n        if (xpriv) this._hdKey = HDKey.fromExtendedKey(xpriv);\n        if (xpub) this._hdKey = HDKey.fromExtendedKey(xpub);\n        this._isViewOnly = !!xpub;\n        if (!this._hdKey)\n            throw new Error('All of seed, xpriv and xpub are undefined');\n        this._isHD = true;\n        this._isHardwareWallet = false;\n    }\n\n    async getPrivateKeyBytes(path) {\n        if (this.isViewOnly) {\n            throw new Error(\n                'Trying to get private key bytes from a view only key'\n            );\n        }\n        return this._hdKey.derive(path).privateKey;\n    }\n\n    get keyToBackup() {\n        if (this.isViewOnly) {\n            throw new Error('Trying to get private key from a view only key');\n        }\n        return this._hdKey.privateExtendedKey;\n    }\n\n    async getxpub(path) {\n        if (this.isViewOnly) return this._hdKey.publicExtendedKey;\n        return this._hdKey.derive(path).publicExtendedKey;\n    }\n\n    getAddress(path) {\n        let child;\n        if (this.isViewOnly) {\n            // If we're view only we can't derive hardened keys, so we'll assume\n            // That the xpub has already been derived\n            child = this._hdKey.derive(\n                path\n                    .split('/')\n                    .filter((n) => !n.includes(\"'\"))\n                    .join('/')\n            );\n        } else {\n            child = this._hdKey.derive(path);\n        }\n        return deriveAddress({ publicKey: bytesToHex(child.publicKey) });\n    }\n\n    wipePrivateData() {\n        if (this._isViewOnly) return;\n\n        this._hdKey = HDKey.fromExtendedKey(this.keyToExport);\n        this._isViewOnly = true;\n    }\n\n    get keyToExport() {\n        if (this._isViewOnly) return this._hdKey.publicExtendedKey;\n        // We need the xpub to point at the account level\n        return this._hdKey.derive(\n            getDerivationPath(false).split('/').slice(0, 4).join('/')\n        ).publicExtendedKey;\n    }\n}\n\nexport class HardwareWalletMasterKey extends MasterKey {\n    constructor() {\n        super();\n        this._isHD = true;\n        this._isHardwareWallet = true;\n    }\n    async getPrivateKeyBytes(_path) {\n        throw new Error('Hardware wallets cannot export private keys');\n    }\n\n    async getAddress(path, { verify } = {}) {\n        return deriveAddress({\n            publicKey: await getHardwareWalletKeys(path, false, verify),\n        });\n    }\n\n    get keyToBackup() {\n        throw new Error(\"Hardware wallets don't have keys to backup\");\n    }\n\n    async getxpub(path) {\n        if (!this.xpub) {\n            this.xpub = await getHardwareWalletKeys(path, true);\n        }\n        return this.xpub;\n    }\n\n    // Hardware Wallets don't have exposed private data\n    wipePrivateData() {}\n\n    get isViewOnly() {\n        return false;\n    }\n    get keyToExport() {\n        return this.getxpub(\n            getDerivationPath(true)\n                .split('/')\n                .filter((v) => !v.includes(\"'\"))\n                .join('/')\n        );\n    }\n}\n\nexport class LegacyMasterKey extends MasterKey {\n    constructor({ pkBytes, address }) {\n        super();\n        this._isHD = false;\n        this._isHardwareWallet = false;\n        this._pkBytes = pkBytes;\n        this._address = address || super.getAddress();\n        this._isViewOnly = !!address;\n    }\n\n    getAddress() {\n        return this._address;\n    }\n\n    get keyToExport() {\n        return this._address;\n    }\n\n    async getPrivateKeyBytes(_path) {\n        if (this.isViewOnly) {\n            throw new Error(\n                'Trying to get private key bytes from a view only key'\n            );\n        }\n        return this._pkBytes;\n    }\n\n    get keyToBackup() {\n        return generateOrEncodePrivkey(this._pkBytes).strWIF;\n    }\n\n    async getxpub(_path) {\n        throw new Error(\n            'Trying to get an extended public key from a legacy address'\n        );\n    }\n\n    wipePrivateData() {\n        this._pkBytes = null;\n        this._isViewOnly = true;\n    }\n}\n\n// Ledger Hardware wallet constants\nexport const LEDGER_ERRS = new Map([\n    // Ledger error code <--> User-friendly string\n    [25870, 'Open the PIVX app on your device'],\n    [25873, 'Open the PIVX app on your device'],\n    [57408, 'Navigate to the PIVX app on your device'],\n    [27157, 'Wrong app! Open the PIVX app on your device'],\n    [27266, 'Wrong app! Open the PIVX app on your device'],\n    [27904, 'Wrong app! Open the PIVX app on your device'],\n    [27010, 'Unlock your Ledger, then try again!'],\n    [27404, 'Unlock your Ledger, then try again!'],\n]);\n\nexport let masterKey;\n\n// Construct a full BIP44 pubkey derivation path from it's parts\nexport function getDerivationPath(\n    fLedger = false,\n    nAccount = 0,\n    nReceiving = 0,\n    nIndex = 0\n) {\n    // Coin-Type is different on Ledger, as such, we modify it if we're using a Ledger to derive a key\n    const strCoinType = fLedger\n        ? cChainParams.current.BIP44_TYPE_LEDGER\n        : cChainParams.current.BIP44_TYPE;\n    if (masterKey && !masterKey.isHD && !fLedger) {\n        return `:)//${strCoinType}'`;\n    }\n    return `m/44'/${strCoinType}'/${nAccount}'/${nReceiving}/${nIndex}`;\n}\n\n// Verify the integrity of a WIF private key, optionally parsing and returning the key payload\nexport function verifyWIF(\n    strWIF = '',\n    fParseBytes = false,\n    skipVerification = false\n) {\n    // Convert from Base58\n    const bWIF = bs58.decode(strWIF);\n\n    if (!skipVerification) {\n        // Verify the byte length\n        if (bWIF.byteLength !== PRIVKEY_BYTE_LENGTH) {\n            throw Error(\n                'Private key length (' +\n                    bWIF.byteLength +\n                    ') is invalid, should be ' +\n                    PRIVKEY_BYTE_LENGTH +\n                    '!'\n            );\n        }\n\n        // Verify the network byte\n        if (bWIF[0] !== cChainParams.current.SECRET_KEY) {\n            // Find the network it's trying to use, if any\n            const cNetwork = Object.keys(cChainParams)\n                .filter((strNet) => strNet !== 'current')\n                .map((strNet) => cChainParams[strNet])\n                .find((cNet) => cNet.SECRET_KEY === bWIF[0]);\n            // Give a specific alert based on the byte properties\n            throw Error(\n                cNetwork\n                    ? 'This private key is for ' +\n                          (cNetwork.isTestnet ? 'Testnet' : 'Mainnet') +\n                          ', wrong network!'\n                    : 'This private key belongs to another coin, or is corrupted.'\n            );\n        }\n\n        // Perform SHA256d hash of the WIF bytes\n        const shaHash = dSHA256(bWIF.slice(0, 34));\n\n        // Verify checksum (comparison by String since JS hates comparing object-like primitives)\n        const bChecksumWIF = bWIF.slice(bWIF.byteLength - 4);\n        const bChecksum = shaHash.slice(0, 4);\n        if (bChecksumWIF.join('') !== bChecksum.join('')) {\n            throw Error(\n                'Private key checksum is invalid, key may be modified, mis-typed, or corrupt.'\n            );\n        }\n    }\n\n    return fParseBytes ? Uint8Array.from(bWIF.slice(1, 33)) : true;\n}\n\n// A convenient alias to verifyWIF that returns the raw byte payload\nexport function parseWIF(strWIF, skipVerification = false) {\n    return verifyWIF(strWIF, true, skipVerification);\n}\n\n// Generate a new private key OR encode an existing private key from raw bytes\nexport function generateOrEncodePrivkey(pkBytesToEncode) {\n    // Private Key Generation\n    const pkBytes = pkBytesToEncode || getSafeRand();\n    const pkNetBytesLen = pkBytes.length + 2;\n    const pkNetBytes = new Uint8Array(pkNetBytesLen);\n\n    // Network Encoding\n    pkNetBytes[0] = cChainParams.current.SECRET_KEY; // Private key prefix (1 byte)\n    writeToUint8(pkNetBytes, pkBytes, 1); // Private key bytes  (32 bytes)\n    pkNetBytes[pkNetBytesLen - 1] = 1; // Leading digit      (1 byte)\n\n    // Double SHA-256 hash\n    const shaObj = dSHA256(pkNetBytes);\n\n    // WIF Checksum\n    const checksum = shaObj.slice(0, 4);\n    const keyWithChecksum = new Uint8Array(pkNetBytesLen + checksum.length);\n    writeToUint8(keyWithChecksum, pkNetBytes, 0);\n    writeToUint8(keyWithChecksum, checksum, pkNetBytesLen);\n\n    // Return both the raw bytes and the WIF format\n    return { pkBytes, strWIF: bs58.encode(keyWithChecksum) };\n}\n\n/**\n * Compress an uncompressed Public Key in byte form\n * @param {Array<Number> | Uint8Array} pubKeyBytes - The uncompressed public key bytes\n * @returns {Array<Number>} The compressed public key bytes\n */\nfunction compressPublicKey(pubKeyBytes) {\n    if (pubKeyBytes.length != 65)\n        throw new Error('Attempting to compress an invalid uncompressed key');\n    const x = pubKeyBytes.slice(1, 33);\n    const y = pubKeyBytes.slice(33);\n\n    // Compressed key is [key_parity + 2, x]\n    return [y[31] % 2 === 0 ? 2 : 3, ...x];\n}\n\n/**\n * Derive a Secp256k1 network-encoded public key (coin address) from raw private or public key bytes\n * @param {Object} options - The object to deconstruct\n * @param {String} [options.publicKey] - The hex encoded public key. Can be both compressed or uncompressed\n * @param {Array<Number> | Uint8Array} [options.pkBytes] - An array of bytes containing the private key\n * @param {\"ENCODED\" | \"UNCOMPRESSED_HEX\" | \"COMPRESSED_HEX\"} options.output - Output\n * @return {String} the public key with the specified encoding\n */\nexport function deriveAddress({ pkBytes, publicKey, output = 'ENCODED' }) {\n    if (!pkBytes && !publicKey) return null;\n    const compress = output !== 'UNCOMPRESSED_HEX';\n    // Public Key Derivation\n    let pubKeyBytes = publicKey\n        ? hexToBytes(publicKey)\n        : nobleSecp256k1.getPublicKey(pkBytes, compress);\n\n    if (output === 'UNCOMPRESSED_HEX') {\n        if (pubKeyBytes.length !== 65) {\n            // It's actually possible, but it's probably not something that we'll need\n            throw new Error(\"Can't uncompress an already compressed key\");\n        }\n        return bytesToHex(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length === 65) {\n        pubKeyBytes = compressPublicKey(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length != 33) {\n        throw new Error('Invalid public key');\n    }\n\n    if (output === 'COMPRESSED_HEX') {\n        return bytesToHex(pubKeyBytes);\n    }\n\n    // First pubkey SHA-256 hash\n    const pubKeyHashing = sha256(new Uint8Array(pubKeyBytes));\n\n    // RIPEMD160 hash\n    const pubKeyHashRipemd160 = ripemd160(pubKeyHashing);\n\n    // Network Encoding\n    const pubKeyHashNetwork = new Uint8Array(pubKeyHashNetworkLen);\n    pubKeyHashNetwork[0] = cChainParams.current.PUBKEY_ADDRESS;\n    writeToUint8(pubKeyHashNetwork, pubKeyHashRipemd160, 1);\n\n    // Double SHA-256 hash\n    const pubKeyHashingSF = dSHA256(pubKeyHashNetwork);\n\n    // Checksum\n    const checksumPubKey = pubKeyHashingSF.slice(0, 4);\n\n    // Public key pre-base58\n    const pubKeyPreBase = new Uint8Array(pubPrebaseLen);\n    writeToUint8(pubKeyPreBase, pubKeyHashNetwork, 0);\n    writeToUint8(pubKeyPreBase, checksumPubKey, pubKeyHashNetworkLen);\n\n    // Encode as Base58 human-readable network address\n    return bs58.encode(pubKeyPreBase);\n}\n\n// Wallet Import\nexport async function importWallet({\n    newWif = false,\n    fRaw = false,\n    isHardwareWallet = false,\n    skipConfirmation = false,\n} = {}) {\n    const strImportConfirm =\n        \"Do you really want to import a new address? If you haven't saved the last private key, the wallet will be LOST forever.\";\n    const walletConfirm =\n        fWalletLoaded && !skipConfirmation\n            ? await confirmPopup({ html: strImportConfirm })\n            : true;\n\n    if (walletConfirm) {\n        if (isHardwareWallet) {\n            // Firefox does NOT support WebUSB, thus cannot work with Hardware wallets out-of-the-box\n            if (navigator.userAgent.includes('Firefox')) {\n                return createAlert(\n                    'warning',\n                    ALERTS.WALLET_FIREFOX_UNSUPPORTED,\n                    [],\n                    7500\n                );\n            }\n\n            const publicKey = await getHardwareWalletKeys(\n                getDerivationPath(true)\n            );\n            // Errors are handled within the above function, so there's no need for an 'else' here, just silent ignore.\n            if (!publicKey) return;\n\n            // Derive our hardware address and import!\n            setMasterKey(new HardwareWalletMasterKey());\n\n            // Hide the 'export wallet' button, it's not relevant to hardware wallets\n            doms.domExportWallet.hidden = true;\n\n            createAlert(\n                'info',\n                ALERTS.WALLET_HARDWARE_WALLET,\n                [{ hardwareWallet: strHardwareName }],\n                12500\n            );\n        } else {\n            // If raw bytes: purely encode the given bytes rather than generating our own bytes\n            if (fRaw) {\n                newWif = generateOrEncodePrivkey(newWif).strWIF;\n\n                // A raw import likely means non-user owned key (i.e: created via VanityGen), thus, we assume safety first and add an exit blocking listener\n                addEventListener('beforeunload', beforeUnloadListener, {\n                    capture: true,\n                });\n            }\n\n            // Select WIF from internal source OR user input (could be: WIF, Mnemonic or xpriv)\n            const privateImportValue = newWif || doms.domPrivKey.value;\n            const passphrase = doms.domPrivKeyPassword.value;\n            doms.domPrivKey.value = '';\n            doms.domPrivKeyPassword.value = '';\n\n            if (await verifyMnemonic(privateImportValue)) {\n                // Generate our masterkey via Mnemonic Phrase\n                const seed = await mnemonicToSeed(\n                    privateImportValue,\n                    passphrase\n                );\n                setMasterKey(new HdMasterKey({ seed }));\n            } else {\n                // Public Key Derivation\n                try {\n                    if (privateImportValue.startsWith('xpub')) {\n                        setMasterKey(\n                            new HdMasterKey({\n                                xpub: privateImportValue,\n                            })\n                        );\n                    } else if (privateImportValue.startsWith('xprv')) {\n                        setMasterKey(\n                            new HdMasterKey({\n                                xpriv: privateImportValue,\n                            })\n                        );\n                    } else if (\n                        privateImportValue.length === 34 &&\n                        cChainParams.current.PUBKEY_PREFIX.includes(\n                            privateImportValue[0]\n                        )\n                    ) {\n                        setMasterKey(\n                            new LegacyMasterKey({\n                                address: privateImportValue,\n                            })\n                        );\n                    } else {\n                        // Lastly, attempt to parse as a WIF private key\n                        const pkBytes = parseWIF(privateImportValue);\n\n                        // Import the raw private key\n                        setMasterKey(new LegacyMasterKey({ pkBytes }));\n                    }\n                } catch (e) {\n                    return createAlert(\n                        'warning',\n                        ALERTS.FAILED_TO_IMPORT + e.message,\n                        [],\n                        6000\n                    );\n                }\n            }\n        }\n\n        // Reaching here: the deserialisation was a full cryptographic success, so a wallet is now imported!\n        fWalletLoaded = true;\n\n        // Hide wipe wallet button if there is no private key\n        if (masterKey.isViewOnly || masterKey.isHardwareWallet) {\n            doms.domWipeWallet.hidden = true;\n            if (hasEncryptedWallet()) {\n                doms.domRestoreWallet.hidden = false;\n            }\n        }\n\n        // For non-HD wallets: hide the 'new address' button, since these are essentially single-address MPW wallets\n        if (!masterKey.isHD) doms.domNewAddress.style.display = 'none';\n\n        // Update the loaded address in the Dashboard\n        getNewAddress({ updateGUI: true });\n\n        // Display Text\n        doms.domGuiWallet.style.display = 'block';\n        doms.domDashboard.click();\n\n        // Update identicon\n        doms.domIdenticon.dataset.jdenticonValue = masterKey.getAddress(\n            getDerivationPath()\n        );\n        jdenticon.update('#identicon');\n\n        // Hide the encryption warning if the user pasted the private key\n        // Or in Testnet mode or is using a hardware wallet or is view-only mode\n        if (\n            !(\n                newWif ||\n                cChainParams.current.isTestnet ||\n                isHardwareWallet ||\n                masterKey.isViewOnly\n            )\n        )\n            doms.domGenKeyWarning.style.display = 'block';\n\n        // Fetch state from explorer\n        if (getNetwork().enabled) refreshChainData();\n\n        // Hide all wallet starter options\n        hideAllWalletOptions();\n    }\n}\n\nfunction setMasterKey(mk) {\n    masterKey = mk;\n    // Update the network master key\n    getNetwork().setMasterKey(masterKey);\n}\n\n// Wallet Generation\nexport async function generateWallet(noUI = false) {\n    const strImportConfirm =\n        \"Do you really want to import a new address? If you haven't saved the last private key, the wallet will be LOST forever.\";\n    const walletConfirm =\n        fWalletLoaded && !noUI\n            ? await confirmPopup({ html: strImportConfirm })\n            : true;\n    if (walletConfirm) {\n        const mnemonic = generateMnemonic();\n\n        const passphrase = !noUI\n            ? await informUserOfMnemonic(mnemonic)\n            : undefined;\n        const seed = await mnemonicToSeed(mnemonic, passphrase);\n\n        // Prompt the user to encrypt the seed\n        setMasterKey(new HdMasterKey({ seed }));\n        fWalletLoaded = true;\n\n        if (!cChainParams.current.isTestnet)\n            doms.domGenKeyWarning.style.display = 'block';\n        // Add a listener to block page unloads until we are sure the user has saved their keys, safety first!\n        addEventListener('beforeunload', beforeUnloadListener, {\n            capture: true,\n        });\n\n        // Display the dashboard\n        doms.domGuiWallet.style.display = 'block';\n        hideAllWalletOptions();\n\n        // Update identicon\n        doms.domIdenticon.dataset.jdenticonValue = masterKey.getAddress(\n            getDerivationPath()\n        );\n        jdenticon.update('#identicon');\n\n        getNewAddress({ updateGUI: true });\n\n        // Refresh the balance UI (why? because it'll also display any 'get some funds!' alerts)\n        getBalance(true);\n        getStakingBalance(true);\n    }\n\n    return masterKey;\n}\n\nexport async function verifyMnemonic(strMnemonic = '', fPopupConfirm = true) {\n    const nWordCount = strMnemonic.trim().split(/\\s+/g).length;\n\n    // Sanity check: Convert to lowercase\n    strMnemonic = strMnemonic.toLowerCase();\n\n    // Ensure it's a word count that makes sense\n    if (nWordCount >= 12 && nWordCount <= 24) {\n        if (!validateMnemonic(strMnemonic)) {\n            // The reason we want to ask the user for confirmation is that the mnemonic\n            // Could have been generated with another app that has a different dictionary\n            return (\n                fPopupConfirm &&\n                (await confirmPopup({\n                    title: 'Unexpected Seed Phrase',\n                    html: 'The seed phrase is either invalid, or was not generated by MPW.<br>Do you still want to proceed?',\n                }))\n            );\n        } else {\n            // Valid count and mnemonic\n            return true;\n        }\n    } else {\n        // Invalid count\n        return false;\n    }\n}\n\nfunction informUserOfMnemonic(mnemonic) {\n    return new Promise((res, _) => {\n        $('#mnemonicModal').modal({ keyboard: false });\n        doms.domMnemonicModalContent.innerText = mnemonic;\n        doms.domMnemonicModalButton.onclick = () => {\n            res(doms.domMnemonicModalPassphrase.value);\n            $('#mnemonicModal').modal('hide');\n        };\n        $('#mnemonicModal').modal('show');\n    });\n}\n\nexport async function encryptWallet(strPassword = '') {\n    // Encrypt the wallet WIF with AES-GCM and a user-chosen password - suitable for browser storage\n    let strEncWIF = await encrypt(masterKey.keyToBackup, strPassword);\n    if (!strEncWIF) return false;\n\n    // Set the encrypted wallet in localStorage\n    localStorage.setItem('encwif', strEncWIF);\n    localStorage.setItem('publicKey', await masterKey.keyToExport);\n\n    // Hide the encryption warning\n    doms.domGenKeyWarning.style.display = 'none';\n\n    // Remove the exit blocker, we can annoy the user less knowing the key is safe in their localstorage!\n    removeEventListener('beforeunload', beforeUnloadListener, {\n        capture: true,\n    });\n}\n\nexport async function decryptWallet(strPassword = '') {\n    // Check if there's any encrypted WIF available\n    const strEncWIF = localStorage.getItem('encwif');\n    if (!strEncWIF || strEncWIF.length < 1) return false;\n\n    // Prompt to decrypt it via password\n    const strDecWIF = await decrypt(strEncWIF, strPassword);\n    if (!strDecWIF || strDecWIF === 'decryption failed!') {\n        if (strDecWIF)\n            return createAlert('warning', 'Incorrect password!', 6000);\n    } else {\n        await importWallet({\n            newWif: strDecWIF,\n            skipConfirmation: true,\n        });\n        // Ensure publicKey is set\n        localStorage.setItem('publicKey', await masterKey.keyToExport);\n        return true;\n    }\n}\n\nexport function hasEncryptedWallet() {\n    return localStorage.getItem('encwif') ? true : false;\n}\n\n// If the privateKey is null then the user connected a hardware wallet\nexport function hasHardwareWallet() {\n    if (!masterKey) return false;\n    return masterKey.isHardwareWallet == true;\n}\n\nexport function hasWalletUnlocked(fIncludeNetwork = false) {\n    if (fIncludeNetwork && !getNetwork().enabled)\n        return createAlert(\n            'warning',\n            ALERTS.WALLET_OFFLINE_AUTOMATIC,\n            [],\n            5500\n        );\n    if (!masterKey) {\n        return createAlert(\n            'warning',\n            ALERTS.WALLET_UNLOCK_IMPORT,\n            [{ unlock: hasEncryptedWallet() ? 'unlock ' : 'import/create' }],\n            3500\n        );\n    } else {\n        return true;\n    }\n}\n\nlet addressIndex = 0;\nexport async function isYourAddress(address) {\n    let i = 0;\n    while (i < addressIndex) {\n        const path = getDerivationPath(masterKey.isHardwareWallet, 0, 0, i);\n        const testAddress = await masterKey.getAddress(path);\n        if (address === testAddress) {\n            return [true, path];\n        }\n        i++;\n    }\n    return [false, 0];\n}\n\nfunction createAddressConfirmation(address) {\n    return `Please confirm this is the address you see on your ${strHardwareName}.\n              <div class=\"seed-phrase\">${address}</div>`;\n}\n\nexport async function getNewAddress({\n    updateGUI = false,\n    verify = false,\n} = {}) {\n    const last = getNetwork().lastWallet;\n    addressIndex = addressIndex > last ? addressIndex : last + 1;\n    if (addressIndex - last > MAX_ACCOUNT_GAP) {\n        // If the user creates more than ${MAX_ACCOUNT_GAP} empty wallets we will not be able to sync them!\n        addressIndex = last;\n    }\n    const path = getDerivationPath(\n        masterKey.isHardwareWallet,\n        0,\n        0,\n        addressIndex\n    );\n    // Use Xpub?\n    const address = await masterKey.getAddress(path);\n    if (verify && masterKey.isHardwareWallet) {\n        // Generate address to present to the user without asking to verify\n        const confAddress = await confirmPopup({\n            title: ALERTS.CONFIRM_POPUP_VERIFY_ADDR,\n            html: createAddressConfirmation(address),\n            resolvePromise: masterKey.getAddress(path, { verify }),\n        });\n        if (address !== confAddress) {\n            throw new Error('User did not verify address');\n        }\n    }\n\n    if (updateGUI) {\n        createQR('pivx:' + address, doms.domModalQR);\n        doms.domModalQrLabel.innerHTML =\n            'pivx:' +\n            address +\n            `<i onclick=\"MPW.toClipboard('${address}', this)\" id=\"guiAddressCopy\" class=\"fas fa-clipboard\" style=\"cursor: pointer; width: 20px;\"></i>`;\n        doms.domModalQR.firstChild.style.width = '100%';\n        doms.domModalQR.firstChild.style.height = 'auto';\n        doms.domModalQR.firstChild.classList.add('no-antialias');\n        document.getElementById('clipboard').value = address;\n    }\n    addressIndex++;\n    return [address, path];\n}\n\nexport let cHardwareWallet = null;\nexport let strHardwareName = '';\nlet transport;\nasync function getHardwareWalletKeys(\n    path,\n    xpub = false,\n    verify = false,\n    _attempts = 0\n) {\n    try {\n        // Check if we haven't setup a connection yet OR the previous connection disconnected\n        if (!cHardwareWallet || transport._disconnectEmitted) {\n            transport = await TransportWebUSB.create();\n            cHardwareWallet = new AppBtc({ transport, currency: 'PIVX' });\n        }\n\n        // Update device info and fetch the pubkey\n        strHardwareName =\n            transport.device.manufacturerName +\n            ' ' +\n            transport.device.productName;\n\n        // Prompt the user in both UIs\n        if (verify) createAlert('info', ALERTS.WALLET_CONFIRM_L, [], 3500);\n        const cPubKey = await cHardwareWallet.getWalletPublicKey(path, {\n            verify,\n            format: 'legacy',\n        });\n\n        if (xpub) {\n            return createXpub({\n                depth: 3,\n                childNumber: 2147483648,\n                chainCode: cPubKey.chainCode,\n                publicKey: cPubKey.publicKey,\n            });\n        } else {\n            return cPubKey.publicKey;\n        }\n    } catch (e) {\n        if (e.message.includes('denied by the user')) {\n            // User denied an operation\n            return false;\n        }\n\n        // If there's no device, nudge the user to plug it in.\n        if (e.message.toLowerCase().includes('no device selected')) {\n            createAlert('info', ALERTS.WALLET_NO_HARDWARE, [], 10000);\n            return false;\n        }\n\n        // If the device is unplugged, or connection lost through other means (such as spontanious device explosion)\n        if (e.message.includes(\"Failed to execute 'transferIn'\")) {\n            createAlert(\n                'info',\n                ALERTS.WALLET_HARDWARE_CONNECTION_LOST,\n                [\n                    {\n                        hardwareWallet: strHardwareName,\n                    },\n                ],\n                10000\n            );\n            return false;\n        }\n        if (_attempts < 10) {\n            // This is an ugly hack :(\n            // in the event where multiple parts of the code decide to ask for an address, just\n            // Retry at most 10 times waiting 200ms each time\n            await sleep(200);\n            return getHardwareWalletKeys(path, xpub, verify, _attempts + 1);\n        }\n\n        // If the ledger is busy, just nudge the user.\n        if (e.message.includes('is busy')) {\n            createAlert(\n                'info',\n                ALERTS.WALLET_HARDWARE_BUSY,\n                [\n                    {\n                        hardwareWallet: strHardwareName,\n                    },\n                ],\n                7500\n            );\n            return false;\n        }\n\n        // Check if this is an expected error\n        if (!e.statusCode || !LEDGER_ERRS.has(e.statusCode)) {\n            console.error(\n                'MISSING LEDGER ERROR-CODE TRANSLATION! - Please report this below error on our GitHub so we can handle it more nicely!'\n            );\n            console.error(e);\n        }\n\n        // Translate the error to a user-friendly string (if possible)\n        createAlert(\n            'warning',\n            ALERTS.WALLET_HARDWARE_ERROR,\n            [\n                {\n                    hardwareWallet: strHardwareName,\n                },\n                {\n                    error: LEDGER_ERRS.get(e.statusCode),\n                },\n            ],\n            5500\n        );\n\n        return false;\n    }\n}\n","import { deriveAddress } from './wallet.js';\nimport { getSafeRand } from './misc.js';\n\nonmessage = function (_evt) {\n    while (true) {\n        const cKeypair = {};\n        cKeypair.priv = getSafeRand();\n\n        cKeypair.pub = deriveAddress({ pkBytes: cKeypair.priv });\n        postMessage(cKeypair);\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [418], () => (__webpack_require__(5858)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"./\" + chunkId + \".mpw.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t649: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkMPW\"] = self[\"webpackChunkMPW\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","bytes","Buffer","toString","current","main","collateralInSats","isTestnet","TICKER","PUBKEY_PREFIX","STAKING_PREFIX","PUBKEY_ADDRESS","SECRET_KEY","BIP44_TYPE","BIP44_TYPE_LEDGER","PROTOCOL_VERSION","MASTERNODE_PORT","Explorers","name","url","Nodes","Consensus","UPGRADE_V6_0","undefined","testnet","nSize","crypto","getRandomValues","Uint8Array","arr","pos","arrLen","length","strERR","type","message","alertVariables","timeout","domAlert","document","createElement","classList","add","setTimeout","style","opacity","zIndex","translatedMessage","variables","forEach","element","replaceAll","Object","keys","values","translateAlerts","innerHTML","destroy","clearTimeout","timer","remove","addEventListener","Error","i","eventEmitter","EventEmitter","MarketSource","cData","strName","strEndpoint","async","this","fetch","json","constructor","super","strCurrency","ensureCacheExists","market_data","current_price","hit","time_to_sync","transaction","id","path","sats","script","vout","height","status","isDelegate","isReward","equalsUTXO","cUTXO","UTXOs","subscribeToNetwork","static","nBlocks","ms","Promise","res","_","removeUTXO","isAlreadyStored","some","getUTXOsByState","nState","filter","removeFromState","cNewUTXO","arrPendingUTXOs","addUTXO","newUTXO","updateUTXO","push","find","utxo","PENDING","CONFIRMED","autoRemoveUTXO","REMOVED","removeWithDelay","error","autoRemoveUTXOs","arrUTXOs","getConfirmed","getStandardUTXOs","getDelegatedUTXOs","getBalance","masternode","cMasternode","JSON","parse","localStorage","getItem","collateralTxId","outidx","isMasternodeUTXO","reduce","a","b","cachedBlockCount","getDelegatedBalance","on","utxos","txid","getUTXOFullInfo","TextEncoder","TextDecoder","mempool","updateGUI","nBalance","nCoins","nLen","toFixed","domGuiBalance","innerText","domAvailToDelegate","then","nPrice","cLocale","Intl","supportedValuesOf","includes","currency","currencyDisplay","maximumFractionDigits","minimumFractionDigits","nValue","domGuiBalanceValue","toLocaleString","domGuiBalanceValueCurrency","domSendAmountValueCurrency","domSendAmountCoinsTicker","domGuiBalanceStaking","Math","floor","domGuiBalanceBoxStaking","fontSize","domAvailToUndelegate","pkBytes","publicKey","output","compress","pubKeyBytes","str","x","slice","compressPublicKey","pubKeyHashing","sha256","pubKeyHashRipemd160","ripemd160","pubKeyHashNetwork","buff","checksumPubKey","pubKeyPreBase","pubKeyHashNetworkLen","Map","onmessage","_evt","cKeypair","priv","pub","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","loaded","__webpack_modules__","call","m","__webpack_exports__","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","key","splice","r","n","getter","__esModule","d","getPrototypeOf","obj","t","value","mode","ns","create","def","indexOf","getOwnPropertyNames","definition","o","defineProperty","enumerable","get","f","e","chunkId","all","promises","u","miniCssF","g","globalThis","Function","window","prop","prototype","hasOwnProperty","Symbol","toStringTag","nmd","paths","children","scriptUrl","importScripts","location","currentScript","src","scripts","getElementsByTagName","replace","p","self","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","bind","data","moreModules","runtime","pop"],"sourceRoot":""}